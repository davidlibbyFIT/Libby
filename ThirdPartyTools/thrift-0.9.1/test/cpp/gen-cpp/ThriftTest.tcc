/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "ThriftTest.h"
#ifndef ThriftTest_TCC
#define ThriftTest_TCC

#include "thrift/async/TAsyncChannel.h"

namespace thrift { namespace test {

template <class Protocol_>
uint32_t ThriftTest_testVoid_args::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testVoid_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testVoid_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testVoid_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testVoid_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testVoid_result::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testVoid_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testVoid_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testVoid_presult::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testVoid_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testVoid_presult");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testString_args::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->thing);
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testString_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testString_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testString_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testString_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->thing)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testString_result::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testString_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testString_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testString_presult::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testString_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testString_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
  xfer += oprot->writeString((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testByte_args::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->thing);
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testByte_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testByte_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testByte_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testByte_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte((*(this->thing)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testByte_result::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testByte_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testByte_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BYTE, 0);
    xfer += oprot->writeByte(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testByte_presult::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testByte_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testByte_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BYTE, 0);
  xfer += oprot->writeByte((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testI32_args::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->thing);
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testI32_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testI32_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testI32_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testI32_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->thing)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testI32_result::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testI32_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testI32_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testI32_presult::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testI32_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testI32_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
  xfer += oprot->writeI32((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testI64_args::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thing);
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testI64_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testI64_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testI64_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testI64_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thing)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testI64_result::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testI64_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testI64_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testI64_presult::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testI64_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testI64_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
  xfer += oprot->writeI64((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testDouble_args::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->thing);
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testDouble_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testDouble_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testDouble_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testDouble_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble((*(this->thing)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testDouble_result::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testDouble_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testDouble_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
    xfer += oprot->writeDouble(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testDouble_presult::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testDouble_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testDouble_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
  xfer += oprot->writeDouble((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testStruct_args::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thing.read(iprot);
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testStruct_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testStruct_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thing.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testStruct_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testStruct_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thing)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testStruct_result::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testStruct_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testStruct_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testStruct_presult::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testStruct_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testStruct_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testNest_args::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thing.read(iprot);
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testNest_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testNest_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thing.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testNest_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testNest_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thing)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testNest_result::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testNest_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testNest_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testNest_presult::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testNest_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testNest_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMap_args::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->thing.clear();
            uint32_t _size229;
            ::apache::thrift::protocol::TType _ktype230;
            ::apache::thrift::protocol::TType _vtype231;
            xfer += iprot->readMapBegin(_ktype230, _vtype231, _size229);
            uint32_t _i233;
            for (_i233 = 0; _i233 < _size229; ++_i233)
            {
              int32_t _key234;
              xfer += iprot->readI32(_key234);
              int32_t& _val235 = this->thing[_key234];
              xfer += iprot->readI32(_val235);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMap_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testMap_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thing.size()));
    std::map<int32_t, int32_t> ::const_iterator _iter236;
    for (_iter236 = this->thing.begin(); _iter236 != this->thing.end(); ++_iter236)
    {
      xfer += oprot->writeI32(_iter236->first);
      xfer += oprot->writeI32(_iter236->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMap_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testMap_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thing)).size()));
    std::map<int32_t, int32_t> ::const_iterator _iter237;
    for (_iter237 = (*(this->thing)).begin(); _iter237 != (*(this->thing)).end(); ++_iter237)
    {
      xfer += oprot->writeI32(_iter237->first);
      xfer += oprot->writeI32(_iter237->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMap_result::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size238;
            ::apache::thrift::protocol::TType _ktype239;
            ::apache::thrift::protocol::TType _vtype240;
            xfer += iprot->readMapBegin(_ktype239, _vtype240, _size238);
            uint32_t _i242;
            for (_i242 = 0; _i242 < _size238; ++_i242)
            {
              int32_t _key243;
              xfer += iprot->readI32(_key243);
              int32_t& _val244 = this->success[_key243];
              xfer += iprot->readI32(_val244);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMap_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testMap_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->success.size()));
      std::map<int32_t, int32_t> ::const_iterator _iter245;
      for (_iter245 = this->success.begin(); _iter245 != this->success.end(); ++_iter245)
      {
        xfer += oprot->writeI32(_iter245->first);
        xfer += oprot->writeI32(_iter245->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMap_presult::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size246;
            ::apache::thrift::protocol::TType _ktype247;
            ::apache::thrift::protocol::TType _vtype248;
            xfer += iprot->readMapBegin(_ktype247, _vtype248, _size246);
            uint32_t _i250;
            for (_i250 = 0; _i250 < _size246; ++_i250)
            {
              int32_t _key251;
              xfer += iprot->readI32(_key251);
              int32_t& _val252 = (*(this->success))[_key251];
              xfer += iprot->readI32(_val252);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMap_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testMap_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->success)).size()));
    std::map<int32_t, int32_t> ::const_iterator _iter253;
    for (_iter253 = (*(this->success)).begin(); _iter253 != (*(this->success)).end(); ++_iter253)
    {
      xfer += oprot->writeI32(_iter253->first);
      xfer += oprot->writeI32(_iter253->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testStringMap_args::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->thing.clear();
            uint32_t _size254;
            ::apache::thrift::protocol::TType _ktype255;
            ::apache::thrift::protocol::TType _vtype256;
            xfer += iprot->readMapBegin(_ktype255, _vtype256, _size254);
            uint32_t _i258;
            for (_i258 = 0; _i258 < _size254; ++_i258)
            {
              std::string _key259;
              xfer += iprot->readString(_key259);
              std::string& _val260 = this->thing[_key259];
              xfer += iprot->readString(_val260);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testStringMap_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testStringMap_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->thing.size()));
    std::map<std::string, std::string> ::const_iterator _iter261;
    for (_iter261 = this->thing.begin(); _iter261 != this->thing.end(); ++_iter261)
    {
      xfer += oprot->writeString(_iter261->first);
      xfer += oprot->writeString(_iter261->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testStringMap_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testStringMap_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->thing)).size()));
    std::map<std::string, std::string> ::const_iterator _iter262;
    for (_iter262 = (*(this->thing)).begin(); _iter262 != (*(this->thing)).end(); ++_iter262)
    {
      xfer += oprot->writeString(_iter262->first);
      xfer += oprot->writeString(_iter262->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testStringMap_result::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size263;
            ::apache::thrift::protocol::TType _ktype264;
            ::apache::thrift::protocol::TType _vtype265;
            xfer += iprot->readMapBegin(_ktype264, _vtype265, _size263);
            uint32_t _i267;
            for (_i267 = 0; _i267 < _size263; ++_i267)
            {
              std::string _key268;
              xfer += iprot->readString(_key268);
              std::string& _val269 = this->success[_key268];
              xfer += iprot->readString(_val269);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testStringMap_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testStringMap_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, std::string> ::const_iterator _iter270;
      for (_iter270 = this->success.begin(); _iter270 != this->success.end(); ++_iter270)
      {
        xfer += oprot->writeString(_iter270->first);
        xfer += oprot->writeString(_iter270->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testStringMap_presult::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size271;
            ::apache::thrift::protocol::TType _ktype272;
            ::apache::thrift::protocol::TType _vtype273;
            xfer += iprot->readMapBegin(_ktype272, _vtype273, _size271);
            uint32_t _i275;
            for (_i275 = 0; _i275 < _size271; ++_i275)
            {
              std::string _key276;
              xfer += iprot->readString(_key276);
              std::string& _val277 = (*(this->success))[_key276];
              xfer += iprot->readString(_val277);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testStringMap_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testStringMap_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->success)).size()));
    std::map<std::string, std::string> ::const_iterator _iter278;
    for (_iter278 = (*(this->success)).begin(); _iter278 != (*(this->success)).end(); ++_iter278)
    {
      xfer += oprot->writeString(_iter278->first);
      xfer += oprot->writeString(_iter278->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testSet_args::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->thing.clear();
            uint32_t _size279;
            ::apache::thrift::protocol::TType _etype282;
            xfer += iprot->readSetBegin(_etype282, _size279);
            uint32_t _i283;
            for (_i283 = 0; _i283 < _size279; ++_i283)
            {
              int32_t _elem284;
              xfer += iprot->readI32(_elem284);
              this->thing.insert(_elem284);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testSet_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testSet_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_SET, 1);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thing.size()));
    std::set<int32_t> ::const_iterator _iter285;
    for (_iter285 = this->thing.begin(); _iter285 != this->thing.end(); ++_iter285)
    {
      xfer += oprot->writeI32((*_iter285));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testSet_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testSet_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_SET, 1);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thing)).size()));
    std::set<int32_t> ::const_iterator _iter286;
    for (_iter286 = (*(this->thing)).begin(); _iter286 != (*(this->thing)).end(); ++_iter286)
    {
      xfer += oprot->writeI32((*_iter286));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testSet_result::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->success.clear();
            uint32_t _size287;
            ::apache::thrift::protocol::TType _etype290;
            xfer += iprot->readSetBegin(_etype290, _size287);
            uint32_t _i291;
            for (_i291 = 0; _i291 < _size287; ++_i291)
            {
              int32_t _elem292;
              xfer += iprot->readI32(_elem292);
              this->success.insert(_elem292);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testSet_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testSet_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_SET, 0);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->success.size()));
      std::set<int32_t> ::const_iterator _iter293;
      for (_iter293 = this->success.begin(); _iter293 != this->success.end(); ++_iter293)
      {
        xfer += oprot->writeI32((*_iter293));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testSet_presult::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            (*(this->success)).clear();
            uint32_t _size294;
            ::apache::thrift::protocol::TType _etype297;
            xfer += iprot->readSetBegin(_etype297, _size294);
            uint32_t _i298;
            for (_i298 = 0; _i298 < _size294; ++_i298)
            {
              int32_t _elem299;
              xfer += iprot->readI32(_elem299);
              (*(this->success)).insert(_elem299);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testSet_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testSet_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_SET, 0);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->success)).size()));
    std::set<int32_t> ::const_iterator _iter300;
    for (_iter300 = (*(this->success)).begin(); _iter300 != (*(this->success)).end(); ++_iter300)
    {
      xfer += oprot->writeI32((*_iter300));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testList_args::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thing.clear();
            uint32_t _size301;
            ::apache::thrift::protocol::TType _etype304;
            xfer += iprot->readListBegin(_etype304, _size301);
            this->thing.resize(_size301);
            uint32_t _i305;
            for (_i305 = 0; _i305 < _size301; ++_i305)
            {
              xfer += iprot->readI32(this->thing[_i305]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testList_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testList_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thing.size()));
    std::vector<int32_t> ::const_iterator _iter306;
    for (_iter306 = this->thing.begin(); _iter306 != this->thing.end(); ++_iter306)
    {
      xfer += oprot->writeI32((*_iter306));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testList_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testList_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thing)).size()));
    std::vector<int32_t> ::const_iterator _iter307;
    for (_iter307 = (*(this->thing)).begin(); _iter307 != (*(this->thing)).end(); ++_iter307)
    {
      xfer += oprot->writeI32((*_iter307));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testList_result::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size308;
            ::apache::thrift::protocol::TType _etype311;
            xfer += iprot->readListBegin(_etype311, _size308);
            this->success.resize(_size308);
            uint32_t _i312;
            for (_i312 = 0; _i312 < _size308; ++_i312)
            {
              xfer += iprot->readI32(this->success[_i312]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testList_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testList_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->success.size()));
      std::vector<int32_t> ::const_iterator _iter313;
      for (_iter313 = this->success.begin(); _iter313 != this->success.end(); ++_iter313)
      {
        xfer += oprot->writeI32((*_iter313));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testList_presult::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size314;
            ::apache::thrift::protocol::TType _etype317;
            xfer += iprot->readListBegin(_etype317, _size314);
            (*(this->success)).resize(_size314);
            uint32_t _i318;
            for (_i318 = 0; _i318 < _size314; ++_i318)
            {
              xfer += iprot->readI32((*(this->success))[_i318]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testList_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testList_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->success)).size()));
    std::vector<int32_t> ::const_iterator _iter319;
    for (_iter319 = (*(this->success)).begin(); _iter319 != (*(this->success)).end(); ++_iter319)
    {
      xfer += oprot->writeI32((*_iter319));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testEnum_args::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast320;
          xfer += iprot->readI32(ecast320);
          this->thing = (Numberz::type)ecast320;
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testEnum_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testEnum_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testEnum_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testEnum_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)(*(this->thing)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testEnum_result::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast321;
          xfer += iprot->readI32(ecast321);
          this->success = (Numberz::type)ecast321;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testEnum_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testEnum_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testEnum_presult::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast322;
          xfer += iprot->readI32(ecast322);
          (*(this->success)) = (Numberz::type)ecast322;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testEnum_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testEnum_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
  xfer += oprot->writeI32((int32_t)(*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testTypedef_args::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thing);
          this->__isset.thing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testTypedef_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testTypedef_args");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testTypedef_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testTypedef_pargs");

  xfer += oprot->writeFieldBegin("thing", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thing)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testTypedef_result::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testTypedef_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testTypedef_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testTypedef_presult::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testTypedef_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testTypedef_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
  xfer += oprot->writeI64((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMapMap_args::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->hello);
          this->__isset.hello = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMapMap_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testMapMap_args");

  xfer += oprot->writeFieldBegin("hello", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->hello);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMapMap_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testMapMap_pargs");

  xfer += oprot->writeFieldBegin("hello", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->hello)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMapMap_result::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size323;
            ::apache::thrift::protocol::TType _ktype324;
            ::apache::thrift::protocol::TType _vtype325;
            xfer += iprot->readMapBegin(_ktype324, _vtype325, _size323);
            uint32_t _i327;
            for (_i327 = 0; _i327 < _size323; ++_i327)
            {
              int32_t _key328;
              xfer += iprot->readI32(_key328);
              std::map<int32_t, int32_t> & _val329 = this->success[_key328];
              {
                _val329.clear();
                uint32_t _size330;
                ::apache::thrift::protocol::TType _ktype331;
                ::apache::thrift::protocol::TType _vtype332;
                xfer += iprot->readMapBegin(_ktype331, _vtype332, _size330);
                uint32_t _i334;
                for (_i334 = 0; _i334 < _size330; ++_i334)
                {
                  int32_t _key335;
                  xfer += iprot->readI32(_key335);
                  int32_t& _val336 = _val329[_key335];
                  xfer += iprot->readI32(_val336);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMapMap_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testMapMap_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->success.size()));
      std::map<int32_t, std::map<int32_t, int32_t> > ::const_iterator _iter337;
      for (_iter337 = this->success.begin(); _iter337 != this->success.end(); ++_iter337)
      {
        xfer += oprot->writeI32(_iter337->first);
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(_iter337->second.size()));
          std::map<int32_t, int32_t> ::const_iterator _iter338;
          for (_iter338 = _iter337->second.begin(); _iter338 != _iter337->second.end(); ++_iter338)
          {
            xfer += oprot->writeI32(_iter338->first);
            xfer += oprot->writeI32(_iter338->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMapMap_presult::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size339;
            ::apache::thrift::protocol::TType _ktype340;
            ::apache::thrift::protocol::TType _vtype341;
            xfer += iprot->readMapBegin(_ktype340, _vtype341, _size339);
            uint32_t _i343;
            for (_i343 = 0; _i343 < _size339; ++_i343)
            {
              int32_t _key344;
              xfer += iprot->readI32(_key344);
              std::map<int32_t, int32_t> & _val345 = (*(this->success))[_key344];
              {
                _val345.clear();
                uint32_t _size346;
                ::apache::thrift::protocol::TType _ktype347;
                ::apache::thrift::protocol::TType _vtype348;
                xfer += iprot->readMapBegin(_ktype347, _vtype348, _size346);
                uint32_t _i350;
                for (_i350 = 0; _i350 < _size346; ++_i350)
                {
                  int32_t _key351;
                  xfer += iprot->readI32(_key351);
                  int32_t& _val352 = _val345[_key351];
                  xfer += iprot->readI32(_val352);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMapMap_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testMapMap_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>((*(this->success)).size()));
    std::map<int32_t, std::map<int32_t, int32_t> > ::const_iterator _iter353;
    for (_iter353 = (*(this->success)).begin(); _iter353 != (*(this->success)).end(); ++_iter353)
    {
      xfer += oprot->writeI32(_iter353->first);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(_iter353->second.size()));
        std::map<int32_t, int32_t> ::const_iterator _iter354;
        for (_iter354 = _iter353->second.begin(); _iter354 != _iter353->second.end(); ++_iter354)
        {
          xfer += oprot->writeI32(_iter354->first);
          xfer += oprot->writeI32(_iter354->second);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testInsanity_args::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->argument.read(iprot);
          this->__isset.argument = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testInsanity_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testInsanity_args");

  xfer += oprot->writeFieldBegin("argument", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->argument.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testInsanity_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testInsanity_pargs");

  xfer += oprot->writeFieldBegin("argument", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->argument)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testInsanity_result::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size355;
            ::apache::thrift::protocol::TType _ktype356;
            ::apache::thrift::protocol::TType _vtype357;
            xfer += iprot->readMapBegin(_ktype356, _vtype357, _size355);
            uint32_t _i359;
            for (_i359 = 0; _i359 < _size355; ++_i359)
            {
              UserId _key360;
              xfer += iprot->readI64(_key360);
              std::map<Numberz::type, Insanity> & _val361 = this->success[_key360];
              {
                _val361.clear();
                uint32_t _size362;
                ::apache::thrift::protocol::TType _ktype363;
                ::apache::thrift::protocol::TType _vtype364;
                xfer += iprot->readMapBegin(_ktype363, _vtype364, _size362);
                uint32_t _i366;
                for (_i366 = 0; _i366 < _size362; ++_i366)
                {
                  Numberz::type _key367;
                  int32_t ecast369;
                  xfer += iprot->readI32(ecast369);
                  _key367 = (Numberz::type)ecast369;
                  Insanity& _val368 = _val361[_key367];
                  xfer += _val368.read(iprot);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testInsanity_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testInsanity_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->success.size()));
      std::map<UserId, std::map<Numberz::type, Insanity> > ::const_iterator _iter370;
      for (_iter370 = this->success.begin(); _iter370 != this->success.end(); ++_iter370)
      {
        xfer += oprot->writeI64(_iter370->first);
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter370->second.size()));
          std::map<Numberz::type, Insanity> ::const_iterator _iter371;
          for (_iter371 = _iter370->second.begin(); _iter371 != _iter370->second.end(); ++_iter371)
          {
            xfer += oprot->writeI32((int32_t)_iter371->first);
            xfer += _iter371->second.write(oprot);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testInsanity_presult::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size372;
            ::apache::thrift::protocol::TType _ktype373;
            ::apache::thrift::protocol::TType _vtype374;
            xfer += iprot->readMapBegin(_ktype373, _vtype374, _size372);
            uint32_t _i376;
            for (_i376 = 0; _i376 < _size372; ++_i376)
            {
              UserId _key377;
              xfer += iprot->readI64(_key377);
              std::map<Numberz::type, Insanity> & _val378 = (*(this->success))[_key377];
              {
                _val378.clear();
                uint32_t _size379;
                ::apache::thrift::protocol::TType _ktype380;
                ::apache::thrift::protocol::TType _vtype381;
                xfer += iprot->readMapBegin(_ktype380, _vtype381, _size379);
                uint32_t _i383;
                for (_i383 = 0; _i383 < _size379; ++_i383)
                {
                  Numberz::type _key384;
                  int32_t ecast386;
                  xfer += iprot->readI32(ecast386);
                  _key384 = (Numberz::type)ecast386;
                  Insanity& _val385 = _val378[_key384];
                  xfer += _val385.read(iprot);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testInsanity_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testInsanity_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>((*(this->success)).size()));
    std::map<UserId, std::map<Numberz::type, Insanity> > ::const_iterator _iter387;
    for (_iter387 = (*(this->success)).begin(); _iter387 != (*(this->success)).end(); ++_iter387)
    {
      xfer += oprot->writeI64(_iter387->first);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter387->second.size()));
        std::map<Numberz::type, Insanity> ::const_iterator _iter388;
        for (_iter388 = _iter387->second.begin(); _iter388 != _iter387->second.end(); ++_iter388)
        {
          xfer += oprot->writeI32((int32_t)_iter388->first);
          xfer += _iter388->second.write(oprot);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMulti_args::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->arg0);
          this->__isset.arg0 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->arg1);
          this->__isset.arg1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->arg2);
          this->__isset.arg2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->arg3.clear();
            uint32_t _size389;
            ::apache::thrift::protocol::TType _ktype390;
            ::apache::thrift::protocol::TType _vtype391;
            xfer += iprot->readMapBegin(_ktype390, _vtype391, _size389);
            uint32_t _i393;
            for (_i393 = 0; _i393 < _size389; ++_i393)
            {
              int16_t _key394;
              xfer += iprot->readI16(_key394);
              std::string& _val395 = this->arg3[_key394];
              xfer += iprot->readString(_val395);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.arg3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast396;
          xfer += iprot->readI32(ecast396);
          this->arg4 = (Numberz::type)ecast396;
          this->__isset.arg4 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->arg5);
          this->__isset.arg5 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMulti_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testMulti_args");

  xfer += oprot->writeFieldBegin("arg0", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->arg0);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg1", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->arg1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg2", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->arg2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg3", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I16, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->arg3.size()));
    std::map<int16_t, std::string> ::const_iterator _iter397;
    for (_iter397 = this->arg3.begin(); _iter397 != this->arg3.end(); ++_iter397)
    {
      xfer += oprot->writeI16(_iter397->first);
      xfer += oprot->writeString(_iter397->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg4", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->arg4);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg5", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->arg5);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMulti_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testMulti_pargs");

  xfer += oprot->writeFieldBegin("arg0", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte((*(this->arg0)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg1", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->arg1)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg2", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->arg2)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg3", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I16, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->arg3)).size()));
    std::map<int16_t, std::string> ::const_iterator _iter398;
    for (_iter398 = (*(this->arg3)).begin(); _iter398 != (*(this->arg3)).end(); ++_iter398)
    {
      xfer += oprot->writeI16(_iter398->first);
      xfer += oprot->writeString(_iter398->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg4", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)(*(this->arg4)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg5", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64((*(this->arg5)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMulti_result::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMulti_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testMulti_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMulti_presult::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMulti_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testMulti_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testException_args::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->arg);
          this->__isset.arg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testException_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testException_args");

  xfer += oprot->writeFieldBegin("arg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->arg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testException_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testException_pargs");

  xfer += oprot->writeFieldBegin("arg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->arg)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testException_result::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err1.read(iprot);
          this->__isset.err1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testException_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testException_result");

  if (this->__isset.err1) {
    xfer += oprot->writeFieldBegin("err1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err1.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testException_presult::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err1.read(iprot);
          this->__isset.err1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testException_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testException_presult");

  if (this->__isset.err1) {
    xfer += oprot->writeFieldBegin("err1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err1.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMultiException_args::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->arg0);
          this->__isset.arg0 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->arg1);
          this->__isset.arg1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMultiException_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testMultiException_args");

  xfer += oprot->writeFieldBegin("arg0", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->arg0);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg1", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->arg1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMultiException_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testMultiException_pargs");

  xfer += oprot->writeFieldBegin("arg0", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->arg0)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg1", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->arg1)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMultiException_result::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err1.read(iprot);
          this->__isset.err1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err2.read(iprot);
          this->__isset.err2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMultiException_result::write(Protocol_* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ThriftTest_testMultiException_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.err1) {
    xfer += oprot->writeFieldBegin("err1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err1.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.err2) {
    xfer += oprot->writeFieldBegin("err2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->err2.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMultiException_presult::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err1.read(iprot);
          this->__isset.err1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err2.read(iprot);
          this->__isset.err2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testMultiException_presult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testMultiException_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.err1) {
    xfer += oprot->writeFieldBegin("err1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->err1.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.err2) {
    xfer += oprot->writeFieldBegin("err2", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->err2.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testOneway_args::read(Protocol_* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->secondsToSleep);
          this->__isset.secondsToSleep = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testOneway_args::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testOneway_args");

  xfer += oprot->writeFieldBegin("secondsToSleep", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->secondsToSleep);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t ThriftTest_testOneway_pargs::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThriftTest_testOneway_pargs");

  xfer += oprot->writeFieldBegin("secondsToSleep", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->secondsToSleep)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testVoid()
{
  send_testVoid();
  recv_testVoid();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testVoid()
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testVoid", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testVoid_pargs args;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testVoid()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testVoid") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testVoid_presult result;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  return;
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testString(std::string& _return, const std::string& thing)
{
  send_testString(thing);
  recv_testString(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testString(const std::string& thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testString", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testString_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testString(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testString") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testString_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testString failed: unknown result");
}

template <class Protocol_>
int8_t ThriftTestClientT<Protocol_>::testByte(const int8_t thing)
{
  send_testByte(thing);
  return recv_testByte();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testByte(const int8_t thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testByte", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testByte_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
int8_t ThriftTestClientT<Protocol_>::recv_testByte()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testByte") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  int8_t _return;
  ThriftTest_testByte_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testByte failed: unknown result");
}

template <class Protocol_>
int32_t ThriftTestClientT<Protocol_>::testI32(const int32_t thing)
{
  send_testI32(thing);
  return recv_testI32();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testI32(const int32_t thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testI32", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testI32_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
int32_t ThriftTestClientT<Protocol_>::recv_testI32()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testI32") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  ThriftTest_testI32_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testI32 failed: unknown result");
}

template <class Protocol_>
int64_t ThriftTestClientT<Protocol_>::testI64(const int64_t thing)
{
  send_testI64(thing);
  return recv_testI64();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testI64(const int64_t thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testI64", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testI64_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
int64_t ThriftTestClientT<Protocol_>::recv_testI64()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testI64") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  int64_t _return;
  ThriftTest_testI64_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testI64 failed: unknown result");
}

template <class Protocol_>
double ThriftTestClientT<Protocol_>::testDouble(const double thing)
{
  send_testDouble(thing);
  return recv_testDouble();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testDouble(const double thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testDouble", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testDouble_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
double ThriftTestClientT<Protocol_>::recv_testDouble()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testDouble") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  double _return;
  ThriftTest_testDouble_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testDouble failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testStruct(Xtruct& _return, const Xtruct& thing)
{
  send_testStruct(thing);
  recv_testStruct(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testStruct(const Xtruct& thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testStruct", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testStruct_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testStruct(Xtruct& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testStruct") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testStruct_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testStruct failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testNest(Xtruct2& _return, const Xtruct2& thing)
{
  send_testNest(thing);
  recv_testNest(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testNest(const Xtruct2& thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testNest", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testNest_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testNest(Xtruct2& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testNest") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testNest_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testNest failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testMap(std::map<int32_t, int32_t> & _return, const std::map<int32_t, int32_t> & thing)
{
  send_testMap(thing);
  recv_testMap(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testMap(const std::map<int32_t, int32_t> & thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testMap", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMap_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testMap(std::map<int32_t, int32_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testMap") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testMap_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMap failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testStringMap(std::map<std::string, std::string> & _return, const std::map<std::string, std::string> & thing)
{
  send_testStringMap(thing);
  recv_testStringMap(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testStringMap(const std::map<std::string, std::string> & thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testStringMap", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testStringMap_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testStringMap(std::map<std::string, std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testStringMap") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testStringMap_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testStringMap failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testSet(std::set<int32_t> & _return, const std::set<int32_t> & thing)
{
  send_testSet(thing);
  recv_testSet(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testSet(const std::set<int32_t> & thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testSet", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testSet_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testSet(std::set<int32_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testSet") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testSet_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testSet failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testList(std::vector<int32_t> & _return, const std::vector<int32_t> & thing)
{
  send_testList(thing);
  recv_testList(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testList(const std::vector<int32_t> & thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testList", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testList_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testList(std::vector<int32_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testList") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testList_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testList failed: unknown result");
}

template <class Protocol_>
Numberz::type ThriftTestClientT<Protocol_>::testEnum(const Numberz::type thing)
{
  send_testEnum(thing);
  return recv_testEnum();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testEnum(const Numberz::type thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testEnum", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testEnum_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
Numberz::type ThriftTestClientT<Protocol_>::recv_testEnum()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testEnum") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  Numberz::type _return;
  ThriftTest_testEnum_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testEnum failed: unknown result");
}

template <class Protocol_>
UserId ThriftTestClientT<Protocol_>::testTypedef(const UserId thing)
{
  send_testTypedef(thing);
  return recv_testTypedef();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testTypedef(const UserId thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testTypedef", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testTypedef_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
UserId ThriftTestClientT<Protocol_>::recv_testTypedef()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testTypedef") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  UserId _return;
  ThriftTest_testTypedef_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testTypedef failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testMapMap(std::map<int32_t, std::map<int32_t, int32_t> > & _return, const int32_t hello)
{
  send_testMapMap(hello);
  recv_testMapMap(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testMapMap(const int32_t hello)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testMapMap", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMapMap_pargs args;
  args.hello = &hello;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testMapMap(std::map<int32_t, std::map<int32_t, int32_t> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testMapMap") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testMapMap_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMapMap failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testInsanity(std::map<UserId, std::map<Numberz::type, Insanity> > & _return, const Insanity& argument)
{
  send_testInsanity(argument);
  recv_testInsanity(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testInsanity(const Insanity& argument)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testInsanity", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testInsanity_pargs args;
  args.argument = &argument;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testInsanity(std::map<UserId, std::map<Numberz::type, Insanity> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testInsanity") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testInsanity_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testInsanity failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testMulti(Xtruct& _return, const int8_t arg0, const int32_t arg1, const int64_t arg2, const std::map<int16_t, std::string> & arg3, const Numberz::type arg4, const UserId arg5)
{
  send_testMulti(arg0, arg1, arg2, arg3, arg4, arg5);
  recv_testMulti(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testMulti(const int8_t arg0, const int32_t arg1, const int64_t arg2, const std::map<int16_t, std::string> & arg3, const Numberz::type arg4, const UserId arg5)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testMulti", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMulti_pargs args;
  args.arg0 = &arg0;
  args.arg1 = &arg1;
  args.arg2 = &arg2;
  args.arg3 = &arg3;
  args.arg4 = &arg4;
  args.arg5 = &arg5;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testMulti(Xtruct& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testMulti") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testMulti_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMulti failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testException(const std::string& arg)
{
  send_testException(arg);
  recv_testException();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testException(const std::string& arg)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testException", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testException_pargs args;
  args.arg = &arg;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testException()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testException") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testException_presult result;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.err1) {
    throw result.err1;
  }
  return;
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testMultiException(Xtruct& _return, const std::string& arg0, const std::string& arg1)
{
  send_testMultiException(arg0, arg1);
  recv_testMultiException(_return);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testMultiException(const std::string& arg0, const std::string& arg1)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMultiException_pargs args;
  args.arg0 = &arg0;
  args.arg1 = &arg1;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::recv_testMultiException(Xtruct& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  this->iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  if (fname.compare("testMultiException") != 0) {
    this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();
  }
  ThriftTest_testMultiException_presult result;
  result.success = &_return;
  result.read(this->iprot_);
  this->iprot_->readMessageEnd();
  this->iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.err1) {
    throw result.err1;
  }
  if (result.__isset.err2) {
    throw result.err2;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMultiException failed: unknown result");
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::testOneway(const int32_t secondsToSleep)
{
  send_testOneway(secondsToSleep);
}

template <class Protocol_>
void ThriftTestClientT<Protocol_>::send_testOneway(const int32_t secondsToSleep)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testOneway", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testOneway_pargs args;
  args.secondsToSleep = &secondsToSleep;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
bool ThriftTestProcessorT<Protocol_>::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  typename ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second.generic))(seqid, iprot, oprot, callContext);
  return true;
}

template <class Protocol_>
bool ThriftTestProcessorT<Protocol_>::dispatchCallTemplated(Protocol_* iprot, Protocol_* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  typename ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second.specialized))(seqid, iprot, oprot, callContext);
  return true;
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testVoid(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testVoid", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testVoid");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testVoid");
  }

  ThriftTest_testVoid_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testVoid", bytes);
  }

  ThriftTest_testVoid_result result;
  try {
    iface_->testVoid();
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testVoid");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testVoid", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testVoid");
  }

  oprot->writeMessageBegin("testVoid", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testVoid", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testVoid(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testVoid", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testVoid");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testVoid");
  }

  ThriftTest_testVoid_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testVoid", bytes);
  }

  ThriftTest_testVoid_result result;
  try {
    iface_->testVoid();
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testVoid");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testVoid", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testVoid");
  }

  oprot->writeMessageBegin("testVoid", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testVoid", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testString(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testString", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testString");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testString");
  }

  ThriftTest_testString_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testString", bytes);
  }

  ThriftTest_testString_result result;
  try {
    iface_->testString(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testString");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testString", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testString");
  }

  oprot->writeMessageBegin("testString", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testString", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testString(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testString", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testString");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testString");
  }

  ThriftTest_testString_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testString", bytes);
  }

  ThriftTest_testString_result result;
  try {
    iface_->testString(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testString");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testString", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testString");
  }

  oprot->writeMessageBegin("testString", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testString", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testByte(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testByte", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testByte");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testByte");
  }

  ThriftTest_testByte_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testByte", bytes);
  }

  ThriftTest_testByte_result result;
  try {
    result.success = iface_->testByte(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testByte");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testByte", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testByte");
  }

  oprot->writeMessageBegin("testByte", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testByte", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testByte(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testByte", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testByte");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testByte");
  }

  ThriftTest_testByte_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testByte", bytes);
  }

  ThriftTest_testByte_result result;
  try {
    result.success = iface_->testByte(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testByte");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testByte", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testByte");
  }

  oprot->writeMessageBegin("testByte", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testByte", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testI32(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI32", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI32");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testI32");
  }

  ThriftTest_testI32_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testI32", bytes);
  }

  ThriftTest_testI32_result result;
  try {
    result.success = iface_->testI32(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testI32");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testI32", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testI32");
  }

  oprot->writeMessageBegin("testI32", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testI32", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testI32(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI32", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI32");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testI32");
  }

  ThriftTest_testI32_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testI32", bytes);
  }

  ThriftTest_testI32_result result;
  try {
    result.success = iface_->testI32(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testI32");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testI32", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testI32");
  }

  oprot->writeMessageBegin("testI32", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testI32", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testI64(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI64", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI64");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testI64");
  }

  ThriftTest_testI64_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testI64", bytes);
  }

  ThriftTest_testI64_result result;
  try {
    result.success = iface_->testI64(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testI64");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testI64", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testI64");
  }

  oprot->writeMessageBegin("testI64", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testI64", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testI64(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI64", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI64");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testI64");
  }

  ThriftTest_testI64_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testI64", bytes);
  }

  ThriftTest_testI64_result result;
  try {
    result.success = iface_->testI64(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testI64");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testI64", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testI64");
  }

  oprot->writeMessageBegin("testI64", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testI64", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testDouble(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testDouble", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testDouble");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testDouble");
  }

  ThriftTest_testDouble_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testDouble", bytes);
  }

  ThriftTest_testDouble_result result;
  try {
    result.success = iface_->testDouble(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testDouble");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testDouble", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testDouble");
  }

  oprot->writeMessageBegin("testDouble", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testDouble", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testDouble(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testDouble", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testDouble");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testDouble");
  }

  ThriftTest_testDouble_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testDouble", bytes);
  }

  ThriftTest_testDouble_result result;
  try {
    result.success = iface_->testDouble(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testDouble");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testDouble", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testDouble");
  }

  oprot->writeMessageBegin("testDouble", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testDouble", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testStruct(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStruct", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStruct");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testStruct");
  }

  ThriftTest_testStruct_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testStruct", bytes);
  }

  ThriftTest_testStruct_result result;
  try {
    iface_->testStruct(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testStruct");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testStruct", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testStruct");
  }

  oprot->writeMessageBegin("testStruct", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testStruct", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testStruct(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStruct", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStruct");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testStruct");
  }

  ThriftTest_testStruct_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testStruct", bytes);
  }

  ThriftTest_testStruct_result result;
  try {
    iface_->testStruct(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testStruct");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testStruct", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testStruct");
  }

  oprot->writeMessageBegin("testStruct", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testStruct", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testNest(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testNest", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testNest");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testNest");
  }

  ThriftTest_testNest_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testNest", bytes);
  }

  ThriftTest_testNest_result result;
  try {
    iface_->testNest(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testNest");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testNest", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testNest");
  }

  oprot->writeMessageBegin("testNest", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testNest", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testNest(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testNest", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testNest");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testNest");
  }

  ThriftTest_testNest_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testNest", bytes);
  }

  ThriftTest_testNest_result result;
  try {
    iface_->testNest(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testNest");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testNest", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testNest");
  }

  oprot->writeMessageBegin("testNest", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testNest", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testMap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testMap");
  }

  ThriftTest_testMap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testMap", bytes);
  }

  ThriftTest_testMap_result result;
  try {
    iface_->testMap(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMap");
  }

  oprot->writeMessageBegin("testMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMap", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testMap(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testMap");
  }

  ThriftTest_testMap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testMap", bytes);
  }

  ThriftTest_testMap_result result;
  try {
    iface_->testMap(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMap");
  }

  oprot->writeMessageBegin("testMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMap", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testStringMap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStringMap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStringMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testStringMap");
  }

  ThriftTest_testStringMap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testStringMap", bytes);
  }

  ThriftTest_testStringMap_result result;
  try {
    iface_->testStringMap(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testStringMap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testStringMap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testStringMap");
  }

  oprot->writeMessageBegin("testStringMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testStringMap", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testStringMap(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStringMap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStringMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testStringMap");
  }

  ThriftTest_testStringMap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testStringMap", bytes);
  }

  ThriftTest_testStringMap_result result;
  try {
    iface_->testStringMap(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testStringMap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testStringMap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testStringMap");
  }

  oprot->writeMessageBegin("testStringMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testStringMap", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testSet(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testSet", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testSet");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testSet");
  }

  ThriftTest_testSet_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testSet", bytes);
  }

  ThriftTest_testSet_result result;
  try {
    iface_->testSet(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testSet");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testSet", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testSet");
  }

  oprot->writeMessageBegin("testSet", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testSet", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testSet(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testSet", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testSet");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testSet");
  }

  ThriftTest_testSet_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testSet", bytes);
  }

  ThriftTest_testSet_result result;
  try {
    iface_->testSet(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testSet");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testSet", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testSet");
  }

  oprot->writeMessageBegin("testSet", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testSet", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testList(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testList", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testList");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testList");
  }

  ThriftTest_testList_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testList", bytes);
  }

  ThriftTest_testList_result result;
  try {
    iface_->testList(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testList");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testList", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testList");
  }

  oprot->writeMessageBegin("testList", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testList", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testList(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testList", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testList");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testList");
  }

  ThriftTest_testList_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testList", bytes);
  }

  ThriftTest_testList_result result;
  try {
    iface_->testList(result.success, args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testList");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testList", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testList");
  }

  oprot->writeMessageBegin("testList", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testList", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testEnum(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testEnum", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testEnum");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testEnum");
  }

  ThriftTest_testEnum_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testEnum", bytes);
  }

  ThriftTest_testEnum_result result;
  try {
    result.success = iface_->testEnum(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testEnum");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testEnum", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testEnum");
  }

  oprot->writeMessageBegin("testEnum", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testEnum", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testEnum(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testEnum", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testEnum");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testEnum");
  }

  ThriftTest_testEnum_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testEnum", bytes);
  }

  ThriftTest_testEnum_result result;
  try {
    result.success = iface_->testEnum(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testEnum");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testEnum", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testEnum");
  }

  oprot->writeMessageBegin("testEnum", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testEnum", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testTypedef(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testTypedef", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testTypedef");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testTypedef");
  }

  ThriftTest_testTypedef_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testTypedef", bytes);
  }

  ThriftTest_testTypedef_result result;
  try {
    result.success = iface_->testTypedef(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testTypedef");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testTypedef", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testTypedef");
  }

  oprot->writeMessageBegin("testTypedef", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testTypedef", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testTypedef(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testTypedef", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testTypedef");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testTypedef");
  }

  ThriftTest_testTypedef_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testTypedef", bytes);
  }

  ThriftTest_testTypedef_result result;
  try {
    result.success = iface_->testTypedef(args.thing);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testTypedef");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testTypedef", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testTypedef");
  }

  oprot->writeMessageBegin("testTypedef", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testTypedef", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testMapMap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMapMap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMapMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testMapMap");
  }

  ThriftTest_testMapMap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testMapMap", bytes);
  }

  ThriftTest_testMapMap_result result;
  try {
    iface_->testMapMap(result.success, args.hello);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMapMap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMapMap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMapMap");
  }

  oprot->writeMessageBegin("testMapMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMapMap", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testMapMap(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMapMap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMapMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testMapMap");
  }

  ThriftTest_testMapMap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testMapMap", bytes);
  }

  ThriftTest_testMapMap_result result;
  try {
    iface_->testMapMap(result.success, args.hello);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMapMap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMapMap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMapMap");
  }

  oprot->writeMessageBegin("testMapMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMapMap", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testInsanity(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testInsanity", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testInsanity");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testInsanity");
  }

  ThriftTest_testInsanity_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testInsanity", bytes);
  }

  ThriftTest_testInsanity_result result;
  try {
    iface_->testInsanity(result.success, args.argument);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testInsanity");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testInsanity", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testInsanity");
  }

  oprot->writeMessageBegin("testInsanity", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testInsanity", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testInsanity(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testInsanity", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testInsanity");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testInsanity");
  }

  ThriftTest_testInsanity_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testInsanity", bytes);
  }

  ThriftTest_testInsanity_result result;
  try {
    iface_->testInsanity(result.success, args.argument);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testInsanity");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testInsanity", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testInsanity");
  }

  oprot->writeMessageBegin("testInsanity", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testInsanity", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testMulti(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMulti", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMulti");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testMulti");
  }

  ThriftTest_testMulti_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testMulti", bytes);
  }

  ThriftTest_testMulti_result result;
  try {
    iface_->testMulti(result.success, args.arg0, args.arg1, args.arg2, args.arg3, args.arg4, args.arg5);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMulti");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMulti", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMulti");
  }

  oprot->writeMessageBegin("testMulti", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMulti", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testMulti(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMulti", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMulti");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testMulti");
  }

  ThriftTest_testMulti_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testMulti", bytes);
  }

  ThriftTest_testMulti_result result;
  try {
    iface_->testMulti(result.success, args.arg0, args.arg1, args.arg2, args.arg3, args.arg4, args.arg5);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMulti");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMulti", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMulti");
  }

  oprot->writeMessageBegin("testMulti", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMulti", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testException(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testException", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testException");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testException");
  }

  ThriftTest_testException_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testException", bytes);
  }

  ThriftTest_testException_result result;
  try {
    iface_->testException(args.arg);
  } catch (Xception &err1) {
    result.err1 = err1;
    result.__isset.err1 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testException");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testException");
  }

  oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testException", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testException(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testException", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testException");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testException");
  }

  ThriftTest_testException_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testException", bytes);
  }

  ThriftTest_testException_result result;
  try {
    iface_->testException(args.arg);
  } catch (Xception &err1) {
    result.err1 = err1;
    result.__isset.err1 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testException");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testException");
  }

  oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testException", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testMultiException(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMultiException", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMultiException");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testMultiException");
  }

  ThriftTest_testMultiException_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testMultiException", bytes);
  }

  ThriftTest_testMultiException_result result;
  try {
    iface_->testMultiException(result.success, args.arg0, args.arg1);
    result.__isset.success = true;
  } catch (Xception &err1) {
    result.err1 = err1;
    result.__isset.err1 = true;
  } catch (Xception2 &err2) {
    result.err2 = err2;
    result.__isset.err2 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMultiException");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMultiException");
  }

  oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMultiException", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testMultiException(int32_t seqid, Protocol_* iprot, Protocol_* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMultiException", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMultiException");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testMultiException");
  }

  ThriftTest_testMultiException_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testMultiException", bytes);
  }

  ThriftTest_testMultiException_result result;
  try {
    iface_->testMultiException(result.success, args.arg0, args.arg1);
    result.__isset.success = true;
  } catch (Xception &err1) {
    result.err1 = err1;
    result.__isset.err1 = true;
  } catch (Xception2 &err2) {
    result.err2 = err2;
    result.__isset.err2 = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMultiException");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMultiException");
  }

  oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMultiException", bytes);
  }
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testOneway(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  (void) seqid;
  (void) oprot;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testOneway", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testOneway");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testOneway");
  }

  ThriftTest_testOneway_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testOneway", bytes);
  }

  try {
    iface_->testOneway(args.secondsToSleep);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testOneway");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "ThriftTest.testOneway");
  }

  return;
}

template <class Protocol_>
void ThriftTestProcessorT<Protocol_>::process_testOneway(int32_t, Protocol_* iprot, Protocol_*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testOneway", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testOneway");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "ThriftTest.testOneway");
  }

  ThriftTest_testOneway_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "ThriftTest.testOneway", bytes);
  }

  try {
    iface_->testOneway(args.secondsToSleep);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testOneway");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "ThriftTest.testOneway");
  }

  return;
}

template <class Protocol_>
::boost::shared_ptr< ::apache::thrift::TProcessor > ThriftTestProcessorFactoryT<Protocol_>::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< ThriftTestIfFactory > cleanup(handlerFactory_);
  ::boost::shared_ptr< ThriftTestIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::boost::shared_ptr< ::apache::thrift::TProcessor > processor(new ThriftTestProcessorT<Protocol_>(handler));
  return processor;
}
template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testVoid(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob)
{
  send_testVoid();
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testVoid()
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testVoid", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testVoid_pargs args;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testVoid()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testVoid") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testVoid_presult result;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    completed = true;
    completed__(true);
    return;
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testString(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const std::string& thing)
{
  send_testString(thing);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testString(const std::string& thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testString", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testString_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testString(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testString") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testString_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testString failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testByte(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const int8_t thing)
{
  send_testByte(thing);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testByte(const int8_t thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testByte", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testByte_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
int8_t ThriftTestCobClientT<Protocol_>::recv_testByte()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testByte") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    int8_t _return;
    ThriftTest_testByte_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testByte failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testI32(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const int32_t thing)
{
  send_testI32(thing);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testI32(const int32_t thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testI32", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testI32_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
int32_t ThriftTestCobClientT<Protocol_>::recv_testI32()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testI32") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    int32_t _return;
    ThriftTest_testI32_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testI32 failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testI64(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const int64_t thing)
{
  send_testI64(thing);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testI64(const int64_t thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testI64", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testI64_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
int64_t ThriftTestCobClientT<Protocol_>::recv_testI64()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testI64") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    int64_t _return;
    ThriftTest_testI64_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testI64 failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testDouble(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const double thing)
{
  send_testDouble(thing);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testDouble(const double thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testDouble", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testDouble_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
double ThriftTestCobClientT<Protocol_>::recv_testDouble()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testDouble") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    double _return;
    ThriftTest_testDouble_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testDouble failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testStruct(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const Xtruct& thing)
{
  send_testStruct(thing);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testStruct(const Xtruct& thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testStruct", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testStruct_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testStruct(Xtruct& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testStruct") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testStruct_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testStruct failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testNest(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const Xtruct2& thing)
{
  send_testNest(thing);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testNest(const Xtruct2& thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testNest", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testNest_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testNest(Xtruct2& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testNest") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testNest_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testNest failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testMap(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const std::map<int32_t, int32_t> & thing)
{
  send_testMap(thing);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testMap(const std::map<int32_t, int32_t> & thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testMap", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMap_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testMap(std::map<int32_t, int32_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testMap") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testMap_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMap failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testStringMap(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const std::map<std::string, std::string> & thing)
{
  send_testStringMap(thing);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testStringMap(const std::map<std::string, std::string> & thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testStringMap", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testStringMap_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testStringMap(std::map<std::string, std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testStringMap") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testStringMap_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testStringMap failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testSet(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const std::set<int32_t> & thing)
{
  send_testSet(thing);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testSet(const std::set<int32_t> & thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testSet", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testSet_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testSet(std::set<int32_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testSet") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testSet_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testSet failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testList(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const std::vector<int32_t> & thing)
{
  send_testList(thing);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testList(const std::vector<int32_t> & thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testList", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testList_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testList(std::vector<int32_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testList") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testList_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testList failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testEnum(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const Numberz::type thing)
{
  send_testEnum(thing);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testEnum(const Numberz::type thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testEnum", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testEnum_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
Numberz::type ThriftTestCobClientT<Protocol_>::recv_testEnum()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testEnum") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    Numberz::type _return;
    ThriftTest_testEnum_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testEnum failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testTypedef(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const UserId thing)
{
  send_testTypedef(thing);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testTypedef(const UserId thing)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testTypedef", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testTypedef_pargs args;
  args.thing = &thing;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
UserId ThriftTestCobClientT<Protocol_>::recv_testTypedef()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testTypedef") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    UserId _return;
    ThriftTest_testTypedef_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testTypedef failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testMapMap(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const int32_t hello)
{
  send_testMapMap(hello);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testMapMap(const int32_t hello)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testMapMap", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMapMap_pargs args;
  args.hello = &hello;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testMapMap(std::map<int32_t, std::map<int32_t, int32_t> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testMapMap") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testMapMap_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMapMap failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testInsanity(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const Insanity& argument)
{
  send_testInsanity(argument);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testInsanity(const Insanity& argument)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testInsanity", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testInsanity_pargs args;
  args.argument = &argument;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testInsanity(std::map<UserId, std::map<Numberz::type, Insanity> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testInsanity") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testInsanity_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testInsanity failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testMulti(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const int8_t arg0, const int32_t arg1, const int64_t arg2, const std::map<int16_t, std::string> & arg3, const Numberz::type arg4, const UserId arg5)
{
  send_testMulti(arg0, arg1, arg2, arg3, arg4, arg5);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testMulti(const int8_t arg0, const int32_t arg1, const int64_t arg2, const std::map<int16_t, std::string> & arg3, const Numberz::type arg4, const UserId arg5)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testMulti", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMulti_pargs args;
  args.arg0 = &arg0;
  args.arg1 = &arg1;
  args.arg2 = &arg2;
  args.arg3 = &arg3;
  args.arg4 = &arg4;
  args.arg5 = &arg5;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testMulti(Xtruct& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testMulti") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testMulti_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMulti failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testException(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const std::string& arg)
{
  send_testException(arg);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testException(const std::string& arg)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testException", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testException_pargs args;
  args.arg = &arg;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testException()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testException") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testException_presult result;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.err1) {
      completed = true;
      completed__(true);
      throw result.err1;
    }
    completed = true;
    completed__(true);
    return;
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testMultiException(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const std::string& arg0, const std::string& arg1)
{
  send_testMultiException(arg0, arg1);
  this->channel_->sendAndRecvMessage(tcxx::bind(cob, this), this->otrans_.get(), this->itrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testMultiException(const std::string& arg0, const std::string& arg1)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testMultiException_pargs args;
  args.arg0 = &arg0;
  args.arg1 = &arg1;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::recv_testMultiException(Xtruct& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    this->iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(this->iprot_);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("testMultiException") != 0) {
      this->iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      this->iprot_->readMessageEnd();
      this->iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    ThriftTest_testMultiException_presult result;
    result.success = &_return;
    result.read(this->iprot_);
    this->iprot_->readMessageEnd();
    this->iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.err1) {
      completed = true;
      completed__(true);
      throw result.err1;
    }
    if (result.__isset.err2) {
      completed = true;
      completed__(true);
      throw result.err2;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "testMultiException failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::testOneway(tcxx::function<void(ThriftTestCobClientT<Protocol_>* client)> cob, const int32_t secondsToSleep)
{
  send_testOneway(secondsToSleep);
  this->channel_->sendMessage(tcxx::bind(cob, this), this->otrans_.get());
}

template <class Protocol_>
void ThriftTestCobClientT<Protocol_>::send_testOneway(const int32_t secondsToSleep)
{
  int32_t cseqid = 0;
  this->oprot_->writeMessageBegin("testOneway", ::apache::thrift::protocol::T_CALL, cseqid);

  ThriftTest_testOneway_pargs args;
  args.secondsToSleep = &secondsToSleep;
  args.write(this->oprot_);

  this->oprot_->writeMessageEnd();
  this->oprot_->getTransport()->writeEnd();
  this->oprot_->getTransport()->flush();
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::dispatchCall(tcxx::function<void(bool ok)> cob, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid) {
  typename ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  (this->*(pfn->second.generic))(cob, seqid, iprot, oprot);
  return;
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::dispatchCallTemplated(tcxx::function<void(bool ok)> cob, Protocol_* iprot, Protocol_* oprot, const std::string& fname, int32_t seqid) {
  typename ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  (this->*(pfn->second.specialized))(cob, seqid, iprot, oprot);
  return;
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testVoid(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testVoid(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testVoid_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testVoid", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testVoid");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testVoid");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testVoid", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testVoid");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testVoid;
  iface_->testVoid(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx));
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testVoid(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testVoid(cob, seqid, _oprot, ctx);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testVoid_presult result;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testVoid", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testVoid");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testVoid");
  }

  oprot->writeMessageBegin("testVoid", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testVoid", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testVoid(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testVoid_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testVoid", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testVoid");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testVoid");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testVoid", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testVoid");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testVoid;
  iface_->testVoid(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx));
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testVoid(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx)
{
  ThriftTest_testVoid_presult result;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testVoid", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testVoid");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testVoid");
  }

  oprot->writeMessageBegin("testVoid", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testVoid", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testString(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testString(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testString_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testString", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testString");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testString");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testString", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testString");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::string& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testString;
  iface_->testString(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testString(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::string& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testString(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testString_presult result;
  result.success = const_cast<std::string*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testString", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testString");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testString");
  }

  oprot->writeMessageBegin("testString", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testString", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testString(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testString_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testString", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testString");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testString");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testString", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testString");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::string& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testString;
  iface_->testString(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testString(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::string& _return)
{
  ThriftTest_testString_presult result;
  result.success = const_cast<std::string*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testString", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testString");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testString");
  }

  oprot->writeMessageBegin("testString", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testString", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testByte(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testByte(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testByte_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testByte", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testByte");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testByte");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testByte", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testByte");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const int8_t& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testByte;
  iface_->testByte(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testByte(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const int8_t& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testByte(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testByte_presult result;
  result.success = const_cast<int8_t*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testByte", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testByte");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testByte");
  }

  oprot->writeMessageBegin("testByte", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testByte", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testByte(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testByte_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testByte", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testByte");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testByte");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testByte", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testByte");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const int8_t& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testByte;
  iface_->testByte(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testByte(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const int8_t& _return)
{
  ThriftTest_testByte_presult result;
  result.success = const_cast<int8_t*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testByte", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testByte");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testByte");
  }

  oprot->writeMessageBegin("testByte", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testByte", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testI32(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testI32(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testI32_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI32", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI32");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testI32");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testI32", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testI32");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const int32_t& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testI32;
  iface_->testI32(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testI32(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const int32_t& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testI32(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testI32_presult result;
  result.success = const_cast<int32_t*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI32", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI32");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testI32");
  }

  oprot->writeMessageBegin("testI32", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testI32", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testI32(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testI32_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI32", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI32");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testI32");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testI32", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testI32");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const int32_t& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testI32;
  iface_->testI32(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testI32(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const int32_t& _return)
{
  ThriftTest_testI32_presult result;
  result.success = const_cast<int32_t*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI32", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI32");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testI32");
  }

  oprot->writeMessageBegin("testI32", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testI32", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testI64(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testI64(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testI64_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI64", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI64");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testI64");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testI64", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testI64");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const int64_t& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testI64;
  iface_->testI64(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testI64(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const int64_t& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testI64(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testI64_presult result;
  result.success = const_cast<int64_t*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI64", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI64");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testI64");
  }

  oprot->writeMessageBegin("testI64", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testI64", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testI64(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testI64_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI64", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI64");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testI64");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testI64", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testI64");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const int64_t& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testI64;
  iface_->testI64(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testI64(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const int64_t& _return)
{
  ThriftTest_testI64_presult result;
  result.success = const_cast<int64_t*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testI64", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testI64");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testI64");
  }

  oprot->writeMessageBegin("testI64", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testI64", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testDouble(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testDouble(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testDouble_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testDouble", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testDouble");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testDouble");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testDouble", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testDouble");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const double& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testDouble;
  iface_->testDouble(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testDouble(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const double& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testDouble(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testDouble_presult result;
  result.success = const_cast<double*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testDouble", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testDouble");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testDouble");
  }

  oprot->writeMessageBegin("testDouble", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testDouble", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testDouble(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testDouble_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testDouble", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testDouble");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testDouble");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testDouble", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testDouble");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const double& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testDouble;
  iface_->testDouble(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testDouble(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const double& _return)
{
  ThriftTest_testDouble_presult result;
  result.success = const_cast<double*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testDouble", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testDouble");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testDouble");
  }

  oprot->writeMessageBegin("testDouble", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testDouble", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testStruct(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testStruct(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testStruct_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStruct", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStruct");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testStruct");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testStruct", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testStruct");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Xtruct& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testStruct;
  iface_->testStruct(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testStruct(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Xtruct& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testStruct(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testStruct_presult result;
  result.success = const_cast<Xtruct*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStruct", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStruct");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testStruct");
  }

  oprot->writeMessageBegin("testStruct", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testStruct", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testStruct(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testStruct_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStruct", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStruct");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testStruct");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testStruct", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testStruct");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Xtruct& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testStruct;
  iface_->testStruct(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testStruct(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Xtruct& _return)
{
  ThriftTest_testStruct_presult result;
  result.success = const_cast<Xtruct*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStruct", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStruct");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testStruct");
  }

  oprot->writeMessageBegin("testStruct", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testStruct", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testNest(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testNest(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testNest_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testNest", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testNest");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testNest");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testNest", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testNest");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Xtruct2& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testNest;
  iface_->testNest(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testNest(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Xtruct2& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testNest(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testNest_presult result;
  result.success = const_cast<Xtruct2*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testNest", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testNest");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testNest");
  }

  oprot->writeMessageBegin("testNest", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testNest", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testNest(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testNest_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testNest", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testNest");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testNest");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testNest", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testNest");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Xtruct2& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testNest;
  iface_->testNest(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testNest(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Xtruct2& _return)
{
  ThriftTest_testNest_presult result;
  result.success = const_cast<Xtruct2*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testNest", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testNest");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testNest");
  }

  oprot->writeMessageBegin("testNest", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testNest", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testMap(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testMap(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testMap_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMap");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testMap");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testMap", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMap");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<int32_t, int32_t> & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testMap;
  iface_->testMap(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testMap(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<int32_t, int32_t> & _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testMap(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testMap_presult result;
  result.success = const_cast<std::map<int32_t, int32_t> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMap");
  }

  oprot->writeMessageBegin("testMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMap", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testMap(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testMap_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMap");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testMap");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testMap", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMap");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::map<int32_t, int32_t> & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testMap;
  iface_->testMap(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testMap(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::map<int32_t, int32_t> & _return)
{
  ThriftTest_testMap_presult result;
  result.success = const_cast<std::map<int32_t, int32_t> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMap");
  }

  oprot->writeMessageBegin("testMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMap", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testStringMap(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testStringMap(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testStringMap_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStringMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStringMap");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testStringMap");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testStringMap", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testStringMap");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<std::string, std::string> & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testStringMap;
  iface_->testStringMap(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testStringMap(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<std::string, std::string> & _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testStringMap(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testStringMap_presult result;
  result.success = const_cast<std::map<std::string, std::string> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStringMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStringMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testStringMap");
  }

  oprot->writeMessageBegin("testStringMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testStringMap", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testStringMap(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testStringMap_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStringMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStringMap");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testStringMap");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testStringMap", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testStringMap");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::map<std::string, std::string> & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testStringMap;
  iface_->testStringMap(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testStringMap(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::map<std::string, std::string> & _return)
{
  ThriftTest_testStringMap_presult result;
  result.success = const_cast<std::map<std::string, std::string> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testStringMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testStringMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testStringMap");
  }

  oprot->writeMessageBegin("testStringMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testStringMap", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testSet(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testSet(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testSet_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testSet", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testSet");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testSet");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testSet", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testSet");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::set<int32_t> & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testSet;
  iface_->testSet(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testSet(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::set<int32_t> & _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testSet(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testSet_presult result;
  result.success = const_cast<std::set<int32_t> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testSet", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testSet");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testSet");
  }

  oprot->writeMessageBegin("testSet", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testSet", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testSet(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testSet_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testSet", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testSet");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testSet");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testSet", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testSet");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::set<int32_t> & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testSet;
  iface_->testSet(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testSet(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::set<int32_t> & _return)
{
  ThriftTest_testSet_presult result;
  result.success = const_cast<std::set<int32_t> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testSet", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testSet");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testSet");
  }

  oprot->writeMessageBegin("testSet", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testSet", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testList(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testList(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testList_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testList", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testList");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testList");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testList", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testList");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<int32_t> & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testList;
  iface_->testList(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testList(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<int32_t> & _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testList(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testList_presult result;
  result.success = const_cast<std::vector<int32_t> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testList", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testList");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testList");
  }

  oprot->writeMessageBegin("testList", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testList", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testList(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testList_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testList", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testList");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testList");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testList", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testList");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::vector<int32_t> & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testList;
  iface_->testList(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testList(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::vector<int32_t> & _return)
{
  ThriftTest_testList_presult result;
  result.success = const_cast<std::vector<int32_t> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testList", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testList");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testList");
  }

  oprot->writeMessageBegin("testList", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testList", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testEnum(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testEnum(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testEnum_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testEnum", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testEnum");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testEnum");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testEnum", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testEnum");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Numberz::type& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testEnum;
  iface_->testEnum(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testEnum(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Numberz::type& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testEnum(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testEnum_presult result;
  result.success = const_cast<Numberz::type*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testEnum", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testEnum");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testEnum");
  }

  oprot->writeMessageBegin("testEnum", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testEnum", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testEnum(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testEnum_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testEnum", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testEnum");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testEnum");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testEnum", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testEnum");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Numberz::type& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testEnum;
  iface_->testEnum(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testEnum(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Numberz::type& _return)
{
  ThriftTest_testEnum_presult result;
  result.success = const_cast<Numberz::type*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testEnum", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testEnum");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testEnum");
  }

  oprot->writeMessageBegin("testEnum", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testEnum", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testTypedef(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testTypedef(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testTypedef_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testTypedef", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testTypedef");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testTypedef");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testTypedef", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testTypedef");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const UserId& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testTypedef;
  iface_->testTypedef(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testTypedef(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const UserId& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testTypedef(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testTypedef_presult result;
  result.success = const_cast<UserId*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testTypedef", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testTypedef");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testTypedef");
  }

  oprot->writeMessageBegin("testTypedef", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testTypedef", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testTypedef(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testTypedef_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testTypedef", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testTypedef");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testTypedef");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testTypedef", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testTypedef");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const UserId& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testTypedef;
  iface_->testTypedef(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.thing);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testTypedef(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const UserId& _return)
{
  ThriftTest_testTypedef_presult result;
  result.success = const_cast<UserId*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testTypedef", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testTypedef");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testTypedef");
  }

  oprot->writeMessageBegin("testTypedef", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testTypedef", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testMapMap(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testMapMap(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testMapMap_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMapMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMapMap");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testMapMap");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testMapMap", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMapMap");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<int32_t, std::map<int32_t, int32_t> > & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testMapMap;
  iface_->testMapMap(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.hello);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testMapMap(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<int32_t, std::map<int32_t, int32_t> > & _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testMapMap(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testMapMap_presult result;
  result.success = const_cast<std::map<int32_t, std::map<int32_t, int32_t> > *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMapMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMapMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMapMap");
  }

  oprot->writeMessageBegin("testMapMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMapMap", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testMapMap(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testMapMap_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMapMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMapMap");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testMapMap");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testMapMap", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMapMap");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::map<int32_t, std::map<int32_t, int32_t> > & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testMapMap;
  iface_->testMapMap(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.hello);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testMapMap(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::map<int32_t, std::map<int32_t, int32_t> > & _return)
{
  ThriftTest_testMapMap_presult result;
  result.success = const_cast<std::map<int32_t, std::map<int32_t, int32_t> > *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMapMap", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMapMap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMapMap");
  }

  oprot->writeMessageBegin("testMapMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMapMap", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testInsanity(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testInsanity(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testInsanity_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testInsanity", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testInsanity");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testInsanity");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testInsanity", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testInsanity");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<UserId, std::map<Numberz::type, Insanity> > & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testInsanity;
  iface_->testInsanity(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.argument);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testInsanity(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<UserId, std::map<Numberz::type, Insanity> > & _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testInsanity(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testInsanity_presult result;
  result.success = const_cast<std::map<UserId, std::map<Numberz::type, Insanity> > *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testInsanity", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testInsanity");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testInsanity");
  }

  oprot->writeMessageBegin("testInsanity", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testInsanity", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testInsanity(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testInsanity_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testInsanity", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testInsanity");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testInsanity");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testInsanity", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testInsanity");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::map<UserId, std::map<Numberz::type, Insanity> > & _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testInsanity;
  iface_->testInsanity(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.argument);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testInsanity(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const std::map<UserId, std::map<Numberz::type, Insanity> > & _return)
{
  ThriftTest_testInsanity_presult result;
  result.success = const_cast<std::map<UserId, std::map<Numberz::type, Insanity> > *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testInsanity", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testInsanity");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testInsanity");
  }

  oprot->writeMessageBegin("testInsanity", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testInsanity", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testMulti(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testMulti(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testMulti_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMulti", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMulti");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testMulti");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testMulti", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMulti");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Xtruct& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testMulti;
  iface_->testMulti(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.arg0,
      args.arg1,
      args.arg2,
      args.arg3,
      args.arg4,
      args.arg5);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testMulti(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Xtruct& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testMulti(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testMulti_presult result;
  result.success = const_cast<Xtruct*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMulti", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMulti");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMulti");
  }

  oprot->writeMessageBegin("testMulti", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMulti", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testMulti(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testMulti_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMulti", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMulti");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testMulti");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testMulti", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMulti");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Xtruct& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testMulti;
  iface_->testMulti(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.arg0,
      args.arg1,
      args.arg2,
      args.arg3,
      args.arg4,
      args.arg5);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testMulti(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Xtruct& _return)
{
  ThriftTest_testMulti_presult result;
  result.success = const_cast<Xtruct*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMulti", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMulti");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMulti");
  }

  oprot->writeMessageBegin("testMulti", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMulti", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testException(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testException(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testException_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testException");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testException");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testException", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testException");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testException;
  void (ThriftTestAsyncProcessorT<Protocol_>::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &ThriftTestAsyncProcessorT<Protocol_>::throw_testException;
  iface_->testException(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.arg);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testException(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testException(cob, seqid, _oprot, ctx);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testException_presult result;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testException");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testException");
  }

  oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testException", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::throw_testException(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return throw_testException(cob, seqid, _oprot, ctx, _throw);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);


  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testException");

  ThriftTest_testException_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (Xception &err1) {
    result.err1 = err1;
    result.__isset.err1 = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testException");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testException");
  }

  oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testException", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testException(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testException_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testException");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testException");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testException", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testException");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testException;
  void (ThriftTestAsyncProcessorT<Protocol_>::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &ThriftTestAsyncProcessorT<Protocol_>::throw_testException;
  iface_->testException(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.arg);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testException(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx)
{
  ThriftTest_testException_presult result;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testException");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testException");
  }

  oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testException", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::throw_testException(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testException");

  ThriftTest_testException_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (Xception &err1) {
    result.err1 = err1;
    result.__isset.err1 = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testException");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testException");
  }

  oprot->writeMessageBegin("testException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testException", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testMultiException(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testMultiException(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testMultiException_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMultiException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMultiException");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testMultiException");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testMultiException", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMultiException");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Xtruct& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testMultiException;
  void (ThriftTestAsyncProcessorT<Protocol_>::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &ThriftTestAsyncProcessorT<Protocol_>::throw_testMultiException;
  iface_->testMultiException(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.arg0,
      args.arg1);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testMultiException(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const Xtruct& _return)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return return_testMultiException(cob, seqid, _oprot, ctx, _return);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  ThriftTest_testMultiException_presult result;
  result.success = const_cast<Xtruct*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMultiException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMultiException");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMultiException");
  }

  oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMultiException", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::throw_testMultiException(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_oprot) {
    return throw_testMultiException(cob, seqid, _oprot, ctx, _throw);
  }
  T_GENERIC_PROTOCOL(this, oprot, _oprot);


  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMultiException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMultiException");

  ThriftTest_testMultiException_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (Xception &err1) {
    result.err1 = err1;
    result.__isset.err1 = true;
  }
  catch (Xception2 &err2) {
    result.err2 = err2;
    result.__isset.err2 = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMultiException");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMultiException");
  }

  oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMultiException", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testMultiException(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  ThriftTest_testMultiException_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMultiException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMultiException");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testMultiException");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testMultiException", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMultiException");
    }
    return cob(false);
  }
  freer.unregister();
  void (ThriftTestAsyncProcessorT<Protocol_>::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Xtruct& _return) =
    &ThriftTestAsyncProcessorT<Protocol_>::return_testMultiException;
  void (ThriftTestAsyncProcessorT<Protocol_>::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &ThriftTestAsyncProcessorT<Protocol_>::throw_testMultiException;
  iface_->testMultiException(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.arg0,
      args.arg1);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::return_testMultiException(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, const Xtruct& _return)
{
  ThriftTest_testMultiException_presult result;
  result.success = const_cast<Xtruct*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMultiException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMultiException");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMultiException");
  }

  oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMultiException", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::throw_testMultiException(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testMultiException", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testMultiException");

  ThriftTest_testMultiException_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (Xception &err1) {
    result.err1 = err1;
    result.__isset.err1 = true;
  }
  catch (Xception2 &err2) {
    result.err2 = err2;
    result.__isset.err2 = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testMultiException");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "ThriftTest.testMultiException");
  }

  oprot->writeMessageBegin("testMultiException", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "ThriftTest.testMultiException", bytes);
  }
  return cob(true);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testOneway(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  Protocol_* _iprot = dynamic_cast<Protocol_*>(iprot);
  Protocol_* _oprot = dynamic_cast<Protocol_*>(oprot);
  if (_iprot && _oprot) {
    return process_testOneway(cob, seqid, _iprot, _oprot);
  }
  T_GENERIC_PROTOCOL(this, iprot, _iprot);
  T_GENERIC_PROTOCOL(this, oprot, _oprot);

  (void) seqid;
  (void) oprot;
  ThriftTest_testOneway_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testOneway", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testOneway");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testOneway");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testOneway", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testOneway");
    }
    return cob(false);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "ThriftTest.testOneway");
  }
  freer.unregister();
  iface_->testOneway(tcxx::bind(cob, true)
,
      args.secondsToSleep);
}

template <class Protocol_>
void ThriftTestAsyncProcessorT<Protocol_>::process_testOneway(tcxx::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot)
{
  (void) seqid;
  (void) oprot;
  ThriftTest_testOneway_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("ThriftTest.testOneway", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ThriftTest.testOneway");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "ThriftTest.testOneway");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "ThriftTest.testOneway", bytes);
    }
  }
  catch (const std::exception& exn) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "ThriftTest.testOneway");
    }
    return cob(false);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "ThriftTest.testOneway");
  }
  freer.unregister();
  iface_->testOneway(tcxx::bind(cob, true)
,
      args.secondsToSleep);
}

template <class Protocol_>
::boost::shared_ptr< ::apache::thrift::async::TAsyncProcessor > ThriftTestAsyncProcessorFactoryT<Protocol_>::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< ThriftTestCobSvIfFactory > cleanup(handlerFactory_);
  ::boost::shared_ptr< ThriftTestCobSvIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::boost::shared_ptr< ::apache::thrift::async::TAsyncProcessor > processor(new ThriftTestAsyncProcessorT<Protocol_>(handler));
  return processor;
}
}} // namespace

#endif
