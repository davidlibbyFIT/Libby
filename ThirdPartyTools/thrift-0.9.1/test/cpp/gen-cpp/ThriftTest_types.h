/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef ThriftTest_TYPES_H
#define ThriftTest_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace thrift { namespace test {

struct Numberz {
  enum type {
    ONE = 1,
    TWO = 2,
    THREE = 3,
    FIVE = 5,
    SIX = 6,
    EIGHT = 8
  };
};

extern const std::map<int, const char*> _Numberz_VALUES_TO_NAMES;

typedef int64_t UserId;

typedef std::map<std::string, class Bonk>  MapType;

typedef struct _Bonk__isset {
  _Bonk__isset() : message(false), type(false) {}
  bool message;
  bool type;
} _Bonk__isset;

class Bonk {
 public:

  static const char* ascii_fingerprint; // = "EEBC915CE44901401D881E6091423036";
  static const uint8_t binary_fingerprint[16]; // = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};

  Bonk() : message(), type(0) {
  }

  virtual ~Bonk() throw() {}

  std::string message;
  int32_t type;

  _Bonk__isset __isset;

  void __set_message(const std::string& val) {
    message = val;
  }

  void __set_type(const int32_t val) {
    type = val;
  }

  bool operator == (const Bonk & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    if (!(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const Bonk &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Bonk & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

void swap(Bonk &a, Bonk &b);

typedef struct _Bools__isset {
  _Bools__isset() : im_true(false), im_false(false) {}
  bool im_true;
  bool im_false;
} _Bools__isset;

class Bools {
 public:

  static const char* ascii_fingerprint; // = "403F0C4586060E367DA428DD09C59C9C";
  static const uint8_t binary_fingerprint[16]; // = {0x40,0x3F,0x0C,0x45,0x86,0x06,0x0E,0x36,0x7D,0xA4,0x28,0xDD,0x09,0xC5,0x9C,0x9C};

  Bools() : im_true(0), im_false(0) {
  }

  virtual ~Bools() throw() {}

  bool im_true;
  bool im_false;

  _Bools__isset __isset;

  void __set_im_true(const bool val) {
    im_true = val;
  }

  void __set_im_false(const bool val) {
    im_false = val;
  }

  bool operator == (const Bools & rhs) const
  {
    if (!(im_true == rhs.im_true))
      return false;
    if (!(im_false == rhs.im_false))
      return false;
    return true;
  }
  bool operator != (const Bools &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Bools & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

void swap(Bools &a, Bools &b);

typedef struct _Xtruct__isset {
  _Xtruct__isset() : string_thing(false), byte_thing(false), i32_thing(false), i64_thing(false) {}
  bool string_thing;
  bool byte_thing;
  bool i32_thing;
  bool i64_thing;
} _Xtruct__isset;

class Xtruct {
 public:

  static const char* ascii_fingerprint; // = "01AAAA2258347790947AE6F75EE27B67";
  static const uint8_t binary_fingerprint[16]; // = {0x01,0xAA,0xAA,0x22,0x58,0x34,0x77,0x90,0x94,0x7A,0xE6,0xF7,0x5E,0xE2,0x7B,0x67};

  Xtruct() : string_thing(), byte_thing(0), i32_thing(0), i64_thing(0) {
  }

  virtual ~Xtruct() throw() {}

  std::string string_thing;
  int8_t byte_thing;
  int32_t i32_thing;
  int64_t i64_thing;

  _Xtruct__isset __isset;

  void __set_string_thing(const std::string& val) {
    string_thing = val;
  }

  void __set_byte_thing(const int8_t val) {
    byte_thing = val;
  }

  void __set_i32_thing(const int32_t val) {
    i32_thing = val;
  }

  void __set_i64_thing(const int64_t val) {
    i64_thing = val;
  }

  bool operator == (const Xtruct & rhs) const
  {
    if (!(string_thing == rhs.string_thing))
      return false;
    if (!(byte_thing == rhs.byte_thing))
      return false;
    if (!(i32_thing == rhs.i32_thing))
      return false;
    if (!(i64_thing == rhs.i64_thing))
      return false;
    return true;
  }
  bool operator != (const Xtruct &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Xtruct & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

void swap(Xtruct &a, Xtruct &b);

typedef struct _Xtruct2__isset {
  _Xtruct2__isset() : byte_thing(false), struct_thing(false), i32_thing(false) {}
  bool byte_thing;
  bool struct_thing;
  bool i32_thing;
} _Xtruct2__isset;

class Xtruct2 {
 public:

  static const char* ascii_fingerprint; // = "0FA9E7DB20337B1935DECB146BE27561";
  static const uint8_t binary_fingerprint[16]; // = {0x0F,0xA9,0xE7,0xDB,0x20,0x33,0x7B,0x19,0x35,0xDE,0xCB,0x14,0x6B,0xE2,0x75,0x61};

  Xtruct2() : byte_thing(0), i32_thing(0) {
  }

  virtual ~Xtruct2() throw() {}

  int8_t byte_thing;
  Xtruct struct_thing;
  int32_t i32_thing;

  _Xtruct2__isset __isset;

  void __set_byte_thing(const int8_t val) {
    byte_thing = val;
  }

  void __set_struct_thing(const Xtruct& val) {
    struct_thing = val;
  }

  void __set_i32_thing(const int32_t val) {
    i32_thing = val;
  }

  bool operator == (const Xtruct2 & rhs) const
  {
    if (!(byte_thing == rhs.byte_thing))
      return false;
    if (!(struct_thing == rhs.struct_thing))
      return false;
    if (!(i32_thing == rhs.i32_thing))
      return false;
    return true;
  }
  bool operator != (const Xtruct2 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Xtruct2 & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

void swap(Xtruct2 &a, Xtruct2 &b);

typedef struct _Xtruct3__isset {
  _Xtruct3__isset() : string_thing(false), changed(false), i32_thing(false), i64_thing(false) {}
  bool string_thing;
  bool changed;
  bool i32_thing;
  bool i64_thing;
} _Xtruct3__isset;

class Xtruct3 {
 public:

  static const char* ascii_fingerprint; // = "7E14E617C7C8E24EC18FE35116D3ECC0";
  static const uint8_t binary_fingerprint[16]; // = {0x7E,0x14,0xE6,0x17,0xC7,0xC8,0xE2,0x4E,0xC1,0x8F,0xE3,0x51,0x16,0xD3,0xEC,0xC0};

  Xtruct3() : string_thing(), changed(0), i32_thing(0), i64_thing(0) {
  }

  virtual ~Xtruct3() throw() {}

  std::string string_thing;
  int32_t changed;
  int32_t i32_thing;
  int64_t i64_thing;

  _Xtruct3__isset __isset;

  void __set_string_thing(const std::string& val) {
    string_thing = val;
  }

  void __set_changed(const int32_t val) {
    changed = val;
  }

  void __set_i32_thing(const int32_t val) {
    i32_thing = val;
  }

  void __set_i64_thing(const int64_t val) {
    i64_thing = val;
  }

  bool operator == (const Xtruct3 & rhs) const
  {
    if (!(string_thing == rhs.string_thing))
      return false;
    if (!(changed == rhs.changed))
      return false;
    if (!(i32_thing == rhs.i32_thing))
      return false;
    if (!(i64_thing == rhs.i64_thing))
      return false;
    return true;
  }
  bool operator != (const Xtruct3 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Xtruct3 & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

void swap(Xtruct3 &a, Xtruct3 &b);

typedef struct _Insanity__isset {
  _Insanity__isset() : userMap(false), xtructs(false) {}
  bool userMap;
  bool xtructs;
} _Insanity__isset;

class Insanity {
 public:

  static const char* ascii_fingerprint; // = "9E7D0680FA87F83E5A0CEF688569EFE3";
  static const uint8_t binary_fingerprint[16]; // = {0x9E,0x7D,0x06,0x80,0xFA,0x87,0xF8,0x3E,0x5A,0x0C,0xEF,0x68,0x85,0x69,0xEF,0xE3};

  Insanity() {
  }

  virtual ~Insanity() throw() {}

  std::map<Numberz::type, UserId>  userMap;
  std::vector<Xtruct>  xtructs;

  _Insanity__isset __isset;

  void __set_userMap(const std::map<Numberz::type, UserId> & val) {
    userMap = val;
  }

  void __set_xtructs(const std::vector<Xtruct> & val) {
    xtructs = val;
  }

  bool operator == (const Insanity & rhs) const
  {
    if (!(userMap == rhs.userMap))
      return false;
    if (!(xtructs == rhs.xtructs))
      return false;
    return true;
  }
  bool operator != (const Insanity &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Insanity & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

void swap(Insanity &a, Insanity &b);

typedef struct _CrazyNesting__isset {
  _CrazyNesting__isset() : string_field(false), set_field(false), binary_field(false) {}
  bool string_field;
  bool set_field;
  bool binary_field;
} _CrazyNesting__isset;

class CrazyNesting {
 public:

  static const char* ascii_fingerprint; // = "65E05391C27EACE759294E3E55DAC83F";
  static const uint8_t binary_fingerprint[16]; // = {0x65,0xE0,0x53,0x91,0xC2,0x7E,0xAC,0xE7,0x59,0x29,0x4E,0x3E,0x55,0xDA,0xC8,0x3F};

  CrazyNesting() : string_field(), binary_field() {
  }

  virtual ~CrazyNesting() throw() {}

  std::string string_field;
  std::set<Insanity>  set_field;
  std::vector<std::map<std::set<int32_t> , std::map<int32_t, std::set<std::vector<std::map<Insanity, std::string> > > > > >  list_field;
  std::string binary_field;

  _CrazyNesting__isset __isset;

  void __set_string_field(const std::string& val) {
    string_field = val;
  }

  void __set_set_field(const std::set<Insanity> & val) {
    set_field = val;
    __isset.set_field = true;
  }

  void __set_list_field(const std::vector<std::map<std::set<int32_t> , std::map<int32_t, std::set<std::vector<std::map<Insanity, std::string> > > > > > & val) {
    list_field = val;
  }

  void __set_binary_field(const std::string& val) {
    binary_field = val;
  }

  bool operator == (const CrazyNesting & rhs) const
  {
    if (!(string_field == rhs.string_field))
      return false;
    if (__isset.set_field != rhs.__isset.set_field)
      return false;
    else if (__isset.set_field && !(set_field == rhs.set_field))
      return false;
    if (!(list_field == rhs.list_field))
      return false;
    if (!(binary_field == rhs.binary_field))
      return false;
    return true;
  }
  bool operator != (const CrazyNesting &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CrazyNesting & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

void swap(CrazyNesting &a, CrazyNesting &b);

typedef struct _Xception__isset {
  _Xception__isset() : errorCode(false), message(false) {}
  bool errorCode;
  bool message;
} _Xception__isset;

class Xception : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "3F5FC93B338687BC7235B1AB103F47B3";
  static const uint8_t binary_fingerprint[16]; // = {0x3F,0x5F,0xC9,0x3B,0x33,0x86,0x87,0xBC,0x72,0x35,0xB1,0xAB,0x10,0x3F,0x47,0xB3};

  Xception() : errorCode(0), message() {
  }

  virtual ~Xception() throw() {}

  int32_t errorCode;
  std::string message;

  _Xception__isset __isset;

  void __set_errorCode(const int32_t val) {
    errorCode = val;
  }

  void __set_message(const std::string& val) {
    message = val;
  }

  bool operator == (const Xception & rhs) const
  {
    if (!(errorCode == rhs.errorCode))
      return false;
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const Xception &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Xception & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

void swap(Xception &a, Xception &b);

typedef struct _Xception2__isset {
  _Xception2__isset() : errorCode(false), struct_thing(false) {}
  bool errorCode;
  bool struct_thing;
} _Xception2__isset;

class Xception2 : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "7B1B1DBEB6FD136E8478F45D0399F3C4";
  static const uint8_t binary_fingerprint[16]; // = {0x7B,0x1B,0x1D,0xBE,0xB6,0xFD,0x13,0x6E,0x84,0x78,0xF4,0x5D,0x03,0x99,0xF3,0xC4};

  Xception2() : errorCode(0) {
  }

  virtual ~Xception2() throw() {}

  int32_t errorCode;
  Xtruct struct_thing;

  _Xception2__isset __isset;

  void __set_errorCode(const int32_t val) {
    errorCode = val;
  }

  void __set_struct_thing(const Xtruct& val) {
    struct_thing = val;
  }

  bool operator == (const Xception2 & rhs) const
  {
    if (!(errorCode == rhs.errorCode))
      return false;
    if (!(struct_thing == rhs.struct_thing))
      return false;
    return true;
  }
  bool operator != (const Xception2 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Xception2 & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

void swap(Xception2 &a, Xception2 &b);


class EmptyStruct {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  EmptyStruct() {
  }

  virtual ~EmptyStruct() throw() {}


  bool operator == (const EmptyStruct & /* rhs */) const
  {
    return true;
  }
  bool operator != (const EmptyStruct &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const EmptyStruct & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

void swap(EmptyStruct &a, EmptyStruct &b);

typedef struct _OneField__isset {
  _OneField__isset() : field(false) {}
  bool field;
} _OneField__isset;

class OneField {
 public:

  static const char* ascii_fingerprint; // = "2C32A565725135A023CB591D1A993CFD";
  static const uint8_t binary_fingerprint[16]; // = {0x2C,0x32,0xA5,0x65,0x72,0x51,0x35,0xA0,0x23,0xCB,0x59,0x1D,0x1A,0x99,0x3C,0xFD};

  OneField() {
  }

  virtual ~OneField() throw() {}

  EmptyStruct field;

  _OneField__isset __isset;

  void __set_field(const EmptyStruct& val) {
    field = val;
  }

  bool operator == (const OneField & rhs) const
  {
    if (!(field == rhs.field))
      return false;
    return true;
  }
  bool operator != (const OneField &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OneField & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

void swap(OneField &a, OneField &b);

typedef struct _VersioningTestV1__isset {
  _VersioningTestV1__isset() : begin_in_both(false), old_string(false), end_in_both(false) {}
  bool begin_in_both;
  bool old_string;
  bool end_in_both;
} _VersioningTestV1__isset;

class VersioningTestV1 {
 public:

  static const char* ascii_fingerprint; // = "CB65C216C3190178AD7ADECF1928CD97";
  static const uint8_t binary_fingerprint[16]; // = {0xCB,0x65,0xC2,0x16,0xC3,0x19,0x01,0x78,0xAD,0x7A,0xDE,0xCF,0x19,0x28,0xCD,0x97};

  VersioningTestV1() : begin_in_both(0), old_string(), end_in_both(0) {
  }

  virtual ~VersioningTestV1() throw() {}

  int32_t begin_in_both;
  std::string old_string;
  int32_t end_in_both;

  _VersioningTestV1__isset __isset;

  void __set_begin_in_both(const int32_t val) {
    begin_in_both = val;
  }

  void __set_old_string(const std::string& val) {
    old_string = val;
  }

  void __set_end_in_both(const int32_t val) {
    end_in_both = val;
  }

  bool operator == (const VersioningTestV1 & rhs) const
  {
    if (!(begin_in_both == rhs.begin_in_both))
      return false;
    if (!(old_string == rhs.old_string))
      return false;
    if (!(end_in_both == rhs.end_in_both))
      return false;
    return true;
  }
  bool operator != (const VersioningTestV1 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VersioningTestV1 & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

void swap(VersioningTestV1 &a, VersioningTestV1 &b);

typedef struct _VersioningTestV2__isset {
  _VersioningTestV2__isset() : begin_in_both(false), newint(false), newbyte(false), newshort(false), newlong(false), newdouble(false), newstruct(false), newlist(false), newset(false), newmap(false), newstring(false), end_in_both(false) {}
  bool begin_in_both;
  bool newint;
  bool newbyte;
  bool newshort;
  bool newlong;
  bool newdouble;
  bool newstruct;
  bool newlist;
  bool newset;
  bool newmap;
  bool newstring;
  bool end_in_both;
} _VersioningTestV2__isset;

class VersioningTestV2 {
 public:

  static const char* ascii_fingerprint; // = "085522DA9EF6E13EF3186B0B4C19DDDB";
  static const uint8_t binary_fingerprint[16]; // = {0x08,0x55,0x22,0xDA,0x9E,0xF6,0xE1,0x3E,0xF3,0x18,0x6B,0x0B,0x4C,0x19,0xDD,0xDB};

  VersioningTestV2() : begin_in_both(0), newint(0), newbyte(0), newshort(0), newlong(0), newdouble(0), newstring(), end_in_both(0) {
  }

  virtual ~VersioningTestV2() throw() {}

  int32_t begin_in_both;
  int32_t newint;
  int8_t newbyte;
  int16_t newshort;
  int64_t newlong;
  double newdouble;
  Bonk newstruct;
  std::vector<int32_t>  newlist;
  std::set<int32_t>  newset;
  std::map<int32_t, int32_t>  newmap;
  std::string newstring;
  int32_t end_in_both;

  _VersioningTestV2__isset __isset;

  void __set_begin_in_both(const int32_t val) {
    begin_in_both = val;
  }

  void __set_newint(const int32_t val) {
    newint = val;
  }

  void __set_newbyte(const int8_t val) {
    newbyte = val;
  }

  void __set_newshort(const int16_t val) {
    newshort = val;
  }

  void __set_newlong(const int64_t val) {
    newlong = val;
  }

  void __set_newdouble(const double val) {
    newdouble = val;
  }

  void __set_newstruct(const Bonk& val) {
    newstruct = val;
  }

  void __set_newlist(const std::vector<int32_t> & val) {
    newlist = val;
  }

  void __set_newset(const std::set<int32_t> & val) {
    newset = val;
  }

  void __set_newmap(const std::map<int32_t, int32_t> & val) {
    newmap = val;
  }

  void __set_newstring(const std::string& val) {
    newstring = val;
  }

  void __set_end_in_both(const int32_t val) {
    end_in_both = val;
  }

  bool operator == (const VersioningTestV2 & rhs) const
  {
    if (!(begin_in_both == rhs.begin_in_both))
      return false;
    if (!(newint == rhs.newint))
      return false;
    if (!(newbyte == rhs.newbyte))
      return false;
    if (!(newshort == rhs.newshort))
      return false;
    if (!(newlong == rhs.newlong))
      return false;
    if (!(newdouble == rhs.newdouble))
      return false;
    if (!(newstruct == rhs.newstruct))
      return false;
    if (!(newlist == rhs.newlist))
      return false;
    if (!(newset == rhs.newset))
      return false;
    if (!(newmap == rhs.newmap))
      return false;
    if (!(newstring == rhs.newstring))
      return false;
    if (!(end_in_both == rhs.end_in_both))
      return false;
    return true;
  }
  bool operator != (const VersioningTestV2 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VersioningTestV2 & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

void swap(VersioningTestV2 &a, VersioningTestV2 &b);

typedef struct _ListTypeVersioningV1__isset {
  _ListTypeVersioningV1__isset() : myints(false), hello(false) {}
  bool myints;
  bool hello;
} _ListTypeVersioningV1__isset;

class ListTypeVersioningV1 {
 public:

  static const char* ascii_fingerprint; // = "CCCCE89C7E9DA10280F5663700677313";
  static const uint8_t binary_fingerprint[16]; // = {0xCC,0xCC,0xE8,0x9C,0x7E,0x9D,0xA1,0x02,0x80,0xF5,0x66,0x37,0x00,0x67,0x73,0x13};

  ListTypeVersioningV1() : hello() {
  }

  virtual ~ListTypeVersioningV1() throw() {}

  std::vector<int32_t>  myints;
  std::string hello;

  _ListTypeVersioningV1__isset __isset;

  void __set_myints(const std::vector<int32_t> & val) {
    myints = val;
  }

  void __set_hello(const std::string& val) {
    hello = val;
  }

  bool operator == (const ListTypeVersioningV1 & rhs) const
  {
    if (!(myints == rhs.myints))
      return false;
    if (!(hello == rhs.hello))
      return false;
    return true;
  }
  bool operator != (const ListTypeVersioningV1 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ListTypeVersioningV1 & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

void swap(ListTypeVersioningV1 &a, ListTypeVersioningV1 &b);

typedef struct _ListTypeVersioningV2__isset {
  _ListTypeVersioningV2__isset() : strings(false), hello(false) {}
  bool strings;
  bool hello;
} _ListTypeVersioningV2__isset;

class ListTypeVersioningV2 {
 public:

  static const char* ascii_fingerprint; // = "BE556BF7091B2DABBA1863D5E458B15F";
  static const uint8_t binary_fingerprint[16]; // = {0xBE,0x55,0x6B,0xF7,0x09,0x1B,0x2D,0xAB,0xBA,0x18,0x63,0xD5,0xE4,0x58,0xB1,0x5F};

  ListTypeVersioningV2() : hello() {
  }

  virtual ~ListTypeVersioningV2() throw() {}

  std::vector<std::string>  strings;
  std::string hello;

  _ListTypeVersioningV2__isset __isset;

  void __set_strings(const std::vector<std::string> & val) {
    strings = val;
  }

  void __set_hello(const std::string& val) {
    hello = val;
  }

  bool operator == (const ListTypeVersioningV2 & rhs) const
  {
    if (!(strings == rhs.strings))
      return false;
    if (!(hello == rhs.hello))
      return false;
    return true;
  }
  bool operator != (const ListTypeVersioningV2 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ListTypeVersioningV2 & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

void swap(ListTypeVersioningV2 &a, ListTypeVersioningV2 &b);

typedef struct _GuessProtocolStruct__isset {
  _GuessProtocolStruct__isset() : map_field(false) {}
  bool map_field;
} _GuessProtocolStruct__isset;

class GuessProtocolStruct {
 public:

  static const char* ascii_fingerprint; // = "C98BFEEE61EF706362155747298111DA";
  static const uint8_t binary_fingerprint[16]; // = {0xC9,0x8B,0xFE,0xEE,0x61,0xEF,0x70,0x63,0x62,0x15,0x57,0x47,0x29,0x81,0x11,0xDA};

  GuessProtocolStruct() {
  }

  virtual ~GuessProtocolStruct() throw() {}

  std::map<std::string, std::string>  map_field;

  _GuessProtocolStruct__isset __isset;

  void __set_map_field(const std::map<std::string, std::string> & val) {
    map_field = val;
  }

  bool operator == (const GuessProtocolStruct & rhs) const
  {
    if (!(map_field == rhs.map_field))
      return false;
    return true;
  }
  bool operator != (const GuessProtocolStruct &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GuessProtocolStruct & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

void swap(GuessProtocolStruct &a, GuessProtocolStruct &b);

typedef struct _LargeDeltas__isset {
  _LargeDeltas__isset() : b1(false), b10(false), b100(false), check_true(false), b1000(false), check_false(false), vertwo2000(false), a_set2500(false), vertwo3000(false), big_numbers(false) {}
  bool b1;
  bool b10;
  bool b100;
  bool check_true;
  bool b1000;
  bool check_false;
  bool vertwo2000;
  bool a_set2500;
  bool vertwo3000;
  bool big_numbers;
} _LargeDeltas__isset;

class LargeDeltas {
 public:

  static const char* ascii_fingerprint; // = "9DD556A67D1276F4D9389D7B3A153019";
  static const uint8_t binary_fingerprint[16]; // = {0x9D,0xD5,0x56,0xA6,0x7D,0x12,0x76,0xF4,0xD9,0x38,0x9D,0x7B,0x3A,0x15,0x30,0x19};

  LargeDeltas() : check_true(0), check_false(0) {
  }

  virtual ~LargeDeltas() throw() {}

  Bools b1;
  Bools b10;
  Bools b100;
  bool check_true;
  Bools b1000;
  bool check_false;
  VersioningTestV2 vertwo2000;
  std::set<std::string>  a_set2500;
  VersioningTestV2 vertwo3000;
  std::vector<int32_t>  big_numbers;

  _LargeDeltas__isset __isset;

  void __set_b1(const Bools& val) {
    b1 = val;
  }

  void __set_b10(const Bools& val) {
    b10 = val;
  }

  void __set_b100(const Bools& val) {
    b100 = val;
  }

  void __set_check_true(const bool val) {
    check_true = val;
  }

  void __set_b1000(const Bools& val) {
    b1000 = val;
  }

  void __set_check_false(const bool val) {
    check_false = val;
  }

  void __set_vertwo2000(const VersioningTestV2& val) {
    vertwo2000 = val;
  }

  void __set_a_set2500(const std::set<std::string> & val) {
    a_set2500 = val;
  }

  void __set_vertwo3000(const VersioningTestV2& val) {
    vertwo3000 = val;
  }

  void __set_big_numbers(const std::vector<int32_t> & val) {
    big_numbers = val;
  }

  bool operator == (const LargeDeltas & rhs) const
  {
    if (!(b1 == rhs.b1))
      return false;
    if (!(b10 == rhs.b10))
      return false;
    if (!(b100 == rhs.b100))
      return false;
    if (!(check_true == rhs.check_true))
      return false;
    if (!(b1000 == rhs.b1000))
      return false;
    if (!(check_false == rhs.check_false))
      return false;
    if (!(vertwo2000 == rhs.vertwo2000))
      return false;
    if (!(a_set2500 == rhs.a_set2500))
      return false;
    if (!(vertwo3000 == rhs.vertwo3000))
      return false;
    if (!(big_numbers == rhs.big_numbers))
      return false;
    return true;
  }
  bool operator != (const LargeDeltas &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LargeDeltas & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

void swap(LargeDeltas &a, LargeDeltas &b);

typedef struct _NestedListsI32x2__isset {
  _NestedListsI32x2__isset() : integerlist(false) {}
  bool integerlist;
} _NestedListsI32x2__isset;

class NestedListsI32x2 {
 public:

  static const char* ascii_fingerprint; // = "156D870DAD538FB7DA6861EB02437141";
  static const uint8_t binary_fingerprint[16]; // = {0x15,0x6D,0x87,0x0D,0xAD,0x53,0x8F,0xB7,0xDA,0x68,0x61,0xEB,0x02,0x43,0x71,0x41};

  NestedListsI32x2() {
  }

  virtual ~NestedListsI32x2() throw() {}

  std::vector<std::vector<int32_t> >  integerlist;

  _NestedListsI32x2__isset __isset;

  void __set_integerlist(const std::vector<std::vector<int32_t> > & val) {
    integerlist = val;
  }

  bool operator == (const NestedListsI32x2 & rhs) const
  {
    if (!(integerlist == rhs.integerlist))
      return false;
    return true;
  }
  bool operator != (const NestedListsI32x2 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NestedListsI32x2 & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

void swap(NestedListsI32x2 &a, NestedListsI32x2 &b);

typedef struct _NestedListsI32x3__isset {
  _NestedListsI32x3__isset() : integerlist(false) {}
  bool integerlist;
} _NestedListsI32x3__isset;

class NestedListsI32x3 {
 public:

  static const char* ascii_fingerprint; // = "481969D8BBB43CDDEBFA0800E2E55AE1";
  static const uint8_t binary_fingerprint[16]; // = {0x48,0x19,0x69,0xD8,0xBB,0xB4,0x3C,0xDD,0xEB,0xFA,0x08,0x00,0xE2,0xE5,0x5A,0xE1};

  NestedListsI32x3() {
  }

  virtual ~NestedListsI32x3() throw() {}

  std::vector<std::vector<std::vector<int32_t> > >  integerlist;

  _NestedListsI32x3__isset __isset;

  void __set_integerlist(const std::vector<std::vector<std::vector<int32_t> > > & val) {
    integerlist = val;
  }

  bool operator == (const NestedListsI32x3 & rhs) const
  {
    if (!(integerlist == rhs.integerlist))
      return false;
    return true;
  }
  bool operator != (const NestedListsI32x3 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NestedListsI32x3 & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

void swap(NestedListsI32x3 &a, NestedListsI32x3 &b);

typedef struct _NestedMixedx2__isset {
  _NestedMixedx2__isset() : int_set_list(false), map_int_strset(false), map_int_strset_list(false) {}
  bool int_set_list;
  bool map_int_strset;
  bool map_int_strset_list;
} _NestedMixedx2__isset;

class NestedMixedx2 {
 public:

  static const char* ascii_fingerprint; // = "ECA6228385A178DDEEF2D6F371457DCB";
  static const uint8_t binary_fingerprint[16]; // = {0xEC,0xA6,0x22,0x83,0x85,0xA1,0x78,0xDD,0xEE,0xF2,0xD6,0xF3,0x71,0x45,0x7D,0xCB};

  NestedMixedx2() {
  }

  virtual ~NestedMixedx2() throw() {}

  std::vector<std::set<int32_t> >  int_set_list;
  std::map<int32_t, std::set<std::string> >  map_int_strset;
  std::vector<std::map<int32_t, std::set<std::string> > >  map_int_strset_list;

  _NestedMixedx2__isset __isset;

  void __set_int_set_list(const std::vector<std::set<int32_t> > & val) {
    int_set_list = val;
  }

  void __set_map_int_strset(const std::map<int32_t, std::set<std::string> > & val) {
    map_int_strset = val;
  }

  void __set_map_int_strset_list(const std::vector<std::map<int32_t, std::set<std::string> > > & val) {
    map_int_strset_list = val;
  }

  bool operator == (const NestedMixedx2 & rhs) const
  {
    if (!(int_set_list == rhs.int_set_list))
      return false;
    if (!(map_int_strset == rhs.map_int_strset))
      return false;
    if (!(map_int_strset_list == rhs.map_int_strset_list))
      return false;
    return true;
  }
  bool operator != (const NestedMixedx2 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NestedMixedx2 & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

void swap(NestedMixedx2 &a, NestedMixedx2 &b);

typedef struct _ListBonks__isset {
  _ListBonks__isset() : bonk(false) {}
  bool bonk;
} _ListBonks__isset;

class ListBonks {
 public:

  static const char* ascii_fingerprint; // = "3967FCB1D2A588AFFB6B3D0713F6F380";
  static const uint8_t binary_fingerprint[16]; // = {0x39,0x67,0xFC,0xB1,0xD2,0xA5,0x88,0xAF,0xFB,0x6B,0x3D,0x07,0x13,0xF6,0xF3,0x80};

  ListBonks() {
  }

  virtual ~ListBonks() throw() {}

  std::vector<Bonk>  bonk;

  _ListBonks__isset __isset;

  void __set_bonk(const std::vector<Bonk> & val) {
    bonk = val;
  }

  bool operator == (const ListBonks & rhs) const
  {
    if (!(bonk == rhs.bonk))
      return false;
    return true;
  }
  bool operator != (const ListBonks &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ListBonks & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

void swap(ListBonks &a, ListBonks &b);

typedef struct _NestedListsBonk__isset {
  _NestedListsBonk__isset() : bonk(false) {}
  bool bonk;
} _NestedListsBonk__isset;

class NestedListsBonk {
 public:

  static const char* ascii_fingerprint; // = "76F53151491F21E430B14A64523C2C02";
  static const uint8_t binary_fingerprint[16]; // = {0x76,0xF5,0x31,0x51,0x49,0x1F,0x21,0xE4,0x30,0xB1,0x4A,0x64,0x52,0x3C,0x2C,0x02};

  NestedListsBonk() {
  }

  virtual ~NestedListsBonk() throw() {}

  std::vector<std::vector<std::vector<Bonk> > >  bonk;

  _NestedListsBonk__isset __isset;

  void __set_bonk(const std::vector<std::vector<std::vector<Bonk> > > & val) {
    bonk = val;
  }

  bool operator == (const NestedListsBonk & rhs) const
  {
    if (!(bonk == rhs.bonk))
      return false;
    return true;
  }
  bool operator != (const NestedListsBonk &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NestedListsBonk & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

void swap(NestedListsBonk &a, NestedListsBonk &b);

typedef struct _BoolTest__isset {
  _BoolTest__isset() : b(true), s(true) {}
  bool b;
  bool s;
} _BoolTest__isset;

class BoolTest {
 public:

  static const char* ascii_fingerprint; // = "B351CA31A26035AB346169C6EFECD393";
  static const uint8_t binary_fingerprint[16]; // = {0xB3,0x51,0xCA,0x31,0xA2,0x60,0x35,0xAB,0x34,0x61,0x69,0xC6,0xEF,0xEC,0xD3,0x93};

  BoolTest() : b(true), s("true") {
  }

  virtual ~BoolTest() throw() {}

  bool b;
  std::string s;

  _BoolTest__isset __isset;

  void __set_b(const bool val) {
    b = val;
    __isset.b = true;
  }

  void __set_s(const std::string& val) {
    s = val;
    __isset.s = true;
  }

  bool operator == (const BoolTest & rhs) const
  {
    if (__isset.b != rhs.__isset.b)
      return false;
    else if (__isset.b && !(b == rhs.b))
      return false;
    if (__isset.s != rhs.__isset.s)
      return false;
    else if (__isset.s && !(s == rhs.s))
      return false;
    return true;
  }
  bool operator != (const BoolTest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BoolTest & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

void swap(BoolTest &a, BoolTest &b);


class StructA {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  StructA() : s() {
  }

  virtual ~StructA() throw() {}

  std::string s;

  void __set_s(const std::string& val) {
    s = val;
  }

  bool operator == (const StructA & rhs) const
  {
    if (!(s == rhs.s))
      return false;
    return true;
  }
  bool operator != (const StructA &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StructA & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

void swap(StructA &a, StructA &b);

typedef struct _StructB__isset {
  _StructB__isset() : aa(false) {}
  bool aa;
} _StructB__isset;

class StructB {
 public:

  static const char* ascii_fingerprint; // = "BA933917D4A6040C47632233A8E4974A";
  static const uint8_t binary_fingerprint[16]; // = {0xBA,0x93,0x39,0x17,0xD4,0xA6,0x04,0x0C,0x47,0x63,0x22,0x33,0xA8,0xE4,0x97,0x4A};

  StructB() {
  }

  virtual ~StructB() throw() {}

  StructA aa;
  StructA ab;

  _StructB__isset __isset;

  void __set_aa(const StructA& val) {
    aa = val;
    __isset.aa = true;
  }

  void __set_ab(const StructA& val) {
    ab = val;
  }

  bool operator == (const StructB & rhs) const
  {
    if (__isset.aa != rhs.__isset.aa)
      return false;
    else if (__isset.aa && !(aa == rhs.aa))
      return false;
    if (!(ab == rhs.ab))
      return false;
    return true;
  }
  bool operator != (const StructB &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StructB & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

};

void swap(StructB &a, StructB &b);

}} // namespace

#include "ThriftTest_types.tcc"

#endif
